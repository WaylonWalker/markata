<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet href="/atom.xsl" type="text/xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title>Documentation</title>
  <subtitle>Documentation for using the Markata static site generator</subtitle>
  <link>https://markata.dev/</link>
  <id>https://markata.dev/docs/</id>

  <link href="https://markata.dev/docs/atom.xml" rel="self" />
  <link href="https://markata.dev/" rel="alternate" />

  <updated>2025-12-09Z</updated>

  <entry>
    <title>Whoops that page was not found</title>

    <id>https://markata.dev/404/</id>
    <link href="https://markata.dev/404/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
404, looks like we can't find the page you are looking for. Try one of these pages.
    ]]></summary>

    <content type="html"><![CDATA[
404, looks like we can't find the page you are looking for.  Try one of these
pages.

<ul>
{% for post in markata.map('post', filter='"markata" not in slug and "tests" not in slug and "404" not in slug') %}
    <li><a href="{{ post.slug }}">{{ post.title or "CHANGELOG" }}</a></li>
{% endfor %}
</ul>
    ]]></content>
  </entry>
  <entry>
    <title>Creating your Navbar</title>

    <id>https://markata.dev/nav/</id>
    <link href="https://markata.dev/nav/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
Creating navbar links with the default markata templates is done by adding links in your configuration within a block. Example The following example will…
    ]]></summary>

    <content type="html"><![CDATA[
Creating navbar links with the default markata templates is done by adding
links in your `markata.toml` configuration within a `markata.nav` block.

## Example

The following example will create two links, one to the root of the site, with
the text `markata` and one to the github repo for markata with the text of
`GitHub`.

```toml
[markata.nav]
'markata'='/'
'GitHub'='https://github.com/WaylonWalker/markata'
```

### Result

The resulting navbar would look something like this.

---

<nav>
   <a href="/">
    markata
   </a>
   <a href="https://github.com/WaylonWalker/markata">
    GitHub
   </a>
</nav>

---

## In your own template

If you want to continue using this method of maintaining your nav links with a
custom template, add this block to your template where you want your nav to
appear.

```html
<nav>
  {% for text, link in markata.config.nav.items() %}
  <a href="{{link}}">{{text}}</a>
  {% endfor %}
</nav>
```
    ]]></content>
  </entry>
  <entry>
    <title>test.py</title>

    <id>https://markata.dev/test/</id>
    <link href="https://markata.dev/test/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
None
    ]]></summary>

    <content type="html"><![CDATA[
---

None

---
    ]]></content>
  </entry>
  <entry>
    <title>Getting Started with Markata</title>

    <id>https://markata.dev/index/</id>
    <link href="https://markata.dev/index/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
Markata is a fully plugins all the way down static site generator for folks who just want their site to get started quickly and build great content, with the…
    ]]></summary>

    <content type="html"><![CDATA[
Markata is a fully plugins all the way down static site generator for
folks who just want their site to get started quickly and build great
content, with the ability to tinker with everything under the hood if
they want to.

## QuickStart

Markata is fully configurable through a `markata.toml` file, but the defaults
allow to build your site right out of the box with nothing more than markdown.

### Create Some Content

```
mkdir pages
cd pages
echo '# My First Post' > first-post.md
echo '# Hello World' > hello-world.md
```

### Build your site

```bash
pip install markata
markata build

# or if pipx is your thing
pipx run markata build
```

### Frontmatter

You will likely want to set things like `title`, `date`, `description`,
`published`, or `template` per post, this can all be done inside yaml frontmatter.

```markdown
---
templateKey: blog-post
tags: ["python"]
title: My Awesome Post
date: 2022-01-21T16:40:34
published: False
---

This is my awesome post.
```

> Frontmatter is not required, but definitely gives you more control over your site.

## Next steps

_blog starter_

The [blog-starter](https://blog-starter.markata.dev/) has a really great write
up on how to use markata. You can see it in your brower at the
[link](https://blog-starter.markata.dev/) or run it yourself `pipx run markata
new blog`.

## Examples Gallary

Markata has a project gallery to show off sites built with markata. Please
[submit](https://github.com/WaylonWalker/markata/issues/78) yours, and check
out the [project-gallery](http://markata.dev/project-gallery/) for inspiration.

## Deploying to a sub route

_gh pages_

To deploy a subroute, add a markata.path_prifix to your config (markata.toml).

```toml
[markata]
path_prefix='my-sub-route'
```

## Source Code

If you have comments, questions, issues, or like it enough to give a ⭐
check out
[waylonwalker/markata](https://github.com/WaylonWalker/markata)

## Markata Docs

Not much is documented yet, lots of work to do on the docs. Checkout
[LifeCycle](https://markata.dev/markata/lifecycle/) to see what a more
finished one looks like.

UPDATE - the
[`base_cli`](https://markata.dev/markata/plugins/base_cli/) is also up to
date and includes a lot of examples of how to use the markata cli.

> **Yes** this library generates it's own docs

- [All Modules](/autodoc/)
- [Core Modules](/core_modules/)
- [Plugins](/plugins/)
- [color theme](/color-theme/)
    ]]></content>
  </entry>
  <entry>
    <title>Creating your Home Page</title>

    <id>https://markata.dev/home-page/</id>
    <link href="https://markata.dev/home-page/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
There are several ways to create your home/landing page, lets walk through them. Default Behavior feed By default if there is no index page, the feed plugin…
    ]]></summary>

    <content type="html"><![CDATA[
There are several ways to create your home/landing page, lets walk through
them.

## Default Behavior
_feed_

By default if there is no index page, the [feed
plugin](/markata/plugins/feeds/) will make a home page for you that simply
lists all the the articles by title.

## index.md
_markdown_

You can also have an `index.md` in your pages directory, and it will become the
`index.html` on at render time.  This is how [markata.dev](https://markata.dev)
achieves it's own home page.

## static/index.html
_html_

If you want something more complicated (i.e. not easily done in markdown), you
can simply just make an `index.html` in your `Markata().config['assets_dir']`
and it will become your home page. 

!!! note
    your default `assets_dir` will be the static diretory in the root of your
    project.  You can change this by adding to your `markata.toml` settings
    file.

    ```toml
    [markata]
    assets_dir = "assets"
    ```

This is how the homepage of [waylonwalker.com](https://waylonwalker.com) is achieved.
    ]]></content>
  </entry>
  <entry>
    <title>Changelog</title>

    <id>https://markata.dev/changelog/</id>
    <link href="https://markata.dev/changelog/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
Markata Changelog 0.11.0 Performance Improvements Perf: increased diskcache size limit to 5GB and reduced cull_limit to minimize expensive eviction operations…
    ]]></summary>

    <content type="html"><![CDATA[
# Markata Changelog

## 0.11.0

### Performance Improvements

- Perf: increased diskcache size limit to 5GB and reduced cull_limit to minimize expensive eviction operations (saves ~4s during cache culling)
- Perf: optimized feed hash generation to use lightweight post identifiers (slug + content_hash) instead of expensive `str(post.to_dict())` serialization (saves ~6s)
- Perf: feeds now cache expensive `feed.map()` calls during hash generation (~7.7s savings)
- Perf: feeds batch directory creation operations (~2s savings)
- Perf: feeds only read XSL files when they exist and need comparison
- Perf: to_json, service_worker, redirects, jinja_env, and post_template now only write files when content changes (prevents unnecessary file system modifications and downstream syncing)

### Cache Invalidation Improvements

- Fix: feeds now properly invalidate cache when post metadata changes (title, date, slug, published, description)
- Fix: feeds now properly invalidate cache when template files are modified
- Fix: post_template now tracks template file changes for cache invalidation
- Fix: redirects now invalidate cache when template files change
- Fix: jinja_md now includes post metadata and version in cache keys
- Fix: standardized cache keys across plugins to include `__version__` for proper invalidation on updates
- Fix: render_markdown now includes backend and extensions in cache key
- Fix: `auto_description` now strips wikilinks, HTML tags, markdown-it attributes (e.g. {.class-name}), Jinja template tags, admonitions (!!!, !!!+, ???, ???+), and HTML comments for cleaner descriptions
- Fix: `publish_html` now properly resolves custom `output_html` paths relative to `output_dir`, preventing files from being written to project root
- Perf: heading_link replaced expensive file I/O with `__version__` in cache key
- Feat: feeds now support atom feeds

### Template Utilities (Breaking for Plugin Authors)

- **BREAKING**: Removed internal `get_template()` functions from `feeds.py` and `post_template.py`
- Feat: added centralized `get_template()`, `get_template_paths()`, and `get_templates_mtime()` to `jinja_env` plugin
- Feat: `get_template()` includes automatic caching with `@lru_cache` and smart fallback handling
- **Plugin authors**: Import from `markata.plugins.jinja_env` instead of using internal functions
  ```python
  from markata.plugins.jinja_env import get_template, get_templates_mtime
  template = get_template(markata.jinja_env, "template.html")
  ```

## 0.10.1

- Release: version bump

## 0.10.0

- Fix: `auto_description` now more accurately returns plain text, does not cut off words, and add an ellipsis.
- Fix: article_html now typed such that it may be a dict without warning
- publish_source now only supports using post models that include a dumps command, i.e. no longer frontmatter post objects
- Fix: Raise warning, do not silently pass no config when `markata.toml` has parse errors
- Feat: Save files only if they have changed, this prevents whole site re-deploys on every change
- Fix: do not use the word index in the slug of the post for links

## 0.9.1

- HUGE DOCS UPDATE
- Fix: feeds now update with any content change
- Fix: og tags should use property not name
- Feat: centralized `jinja_env` plugin that is used for template rendering accross all plugins
- Feat: added support for multiple templates per article <https://markata.dev/multi-template/>
- Feat: skip now supports environment variable `MARKATA_SKIP=true/false` to control skipping

## 0.9.0

- Feat: add skip plugin
- Fix: wikilinks uses a faster and more robust link lookup
- Feat: most plugins now only do work on posts not marked as skip
- Fix: wikilinks now give good error messages to show you which article is throwing the warning

### Performance Improvements

Here are a couple of build times ran back to back on the same content with 0.8.2 and 0.9.0

## Markata

63 posts

- 0.9.0 - 4.308s cold - 1.457s hot
- 0.8.2 - 9.063s cold - 1.542s hot

## waylonwalker.com

exactly 2k posts

- 0.9.0 - 69.200s cold - 2.860 hot
- 0.8.2 - 479s cold - 4.683 hot

#### Core Optimizations

- Added map cache with statistics tracking in Markata core
- Optimized template rendering with bytecode caching
- Parallelized markdown rendering and file loading
- Added configurable cache expiration times for different components

#### Component-specific Optimizations

- Updated auto_description to use markdown-it for better performance
- Improved date parsing with dateparser fallback
- Optimized post loading with bulk processing
- Modernized pydantic validators to use new field_validator syntax

## 0.8.2

- Fix: markata installs setuptools required by one dependency
- Fix: cleaup cli output
- Fix: speed up cli starup with some lazy imports
- Fix: all cache.adds were replaced with cache.set
- Fix: Updated to new typer format requiring name=
- Fix: teardown only runs if a the build process was started, i.e. some clis
  will not need to teardown

## 0.8.1

### Feeds have partials

The `feeds` plugin now has configurable `partial_template` that can be used to
render only the inside of the feeds page.  This is indended to allow you to
load small feeds into a page with htmx.

### Better Jinja Templates

Markata now fully supports jinja templates with a loader that will load from
your templates directory, the markata built-in templates, and from a
dynamically generated templates directory in your .markata.cache directory.

#### cli

You can list out your templates and configuration with the following command

``` bash
markata templates show
```

#### Variables

The following variables are available within jinja templates for post
templates.  This is now consistent accross all three built in plugins that
render jinja templates.

##### post_template

- `__version__` - the version of markata
- `markata` - the markata instance
- `config` - the markata config
- `body` - the body of the post
- `post` - the current post object

##### feeds

Similarly from within rendering feeds.

- `__version__` - the version of markata
- `markata` - the markata instance
- `config` - the markata config
- `posts` - the list of posts
- `post` - a pseudo post object with title, slug, description, and date for template consistency
- `feed` - the current feed object

##### jinja_md

Similar to posts from within jinja_md to render a markdown post as a template.

- `__version__` - the version of markata
- `markata` - the markata instance
- `body` - the body of the post
- `config` - the markata config
- `post` - the current post object

#### Feeds cli

The feeds cli will help show which templates each feed will be using.

``` bash
❯ markata feeds show
                                          Feeds 6
┏━━━━━━━━━━━━━━━━━┳━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃            Feed ┃ posts ┃ config                                                        ┃
┡━━━━━━━━━━━━━━━━━╇━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ project_gallery │ 2     │ DEFAULT_TITLE: All Posts                                      │
│                 │       │ title: Project Gallery                                        │
│                 │       │ slug: project-gallery                                         │
│                 │       │ name: project_gallery                                         │
│                 │       │ filter: 'project-gallery' in str(path)                        │
│                 │       │ sort: title                                                   │
│                 │       │ reverse: False                                                │
│                 │       │ rss: True                                                     │
│                 │       │ sitemap: True                                                 │
│                 │       │ card_template: card.html                                      │
│                 │       │ template: feed.html                                           │
│                 │       │ rss_template: rss.xml                                         │
│                 │       │ sitemap_template: sitemap.xml                                 │
│                 │       │ xsl_template: rss.xsl                                         │
│                 │       │                                                               │
│            docs │ 10    │ DEFAULT_TITLE: All Posts                                      │
│                 │       │ title: Documentation                                          │
│                 │       │ slug: docs                                                    │
│                 │       │ name: docs                                                    │
│                 │       │ filter: "markata" not in slug and "tests" not in slug and ... │
│                 │       │ sort: slug                                                    │
│                 │       │ reverse: False                                                │
│                 │       │ rss: True                                                     │
│                 │       │ sitemap: True                                                 │
│                 │       │ card_template: card.html                                      │
│                 │       │ template: feed.html                                           │
│                 │       │ rss_template: rss.xml                                         │
│                 │       │ sitemap_template: sitemap.xml                                 │
│                 │       │ xsl_template: rss.xsl                                         │
│                 │       │                                                               │
│         autodoc │ 17    │ DEFAULT_TITLE: All Posts                                      │
│                 │       │ title: AutoDoc Python Modules.                                │
│                 │       │ slug: autodoc                                                 │
│                 │       │ name: autodoc                                                 │
│                 │       │ filter: "markata" in slug and "plugin" not in slug and "te... │
│                 │       │ sort: slug                                                    │
│                 │       │ reverse: False                                                │
│                 │       │ rss: True                                                     │
│                 │       │ sitemap: True                                                 │
│                 │       │ card_template: card.html                                      │
│                 │       │ template: feed.html                                           │
│                 │       │ rss_template: rss.xml                                         │
│                 │       │ sitemap_template: sitemap.xml                                 │
│                 │       │ xsl_template: rss.xsl                                         │
│                 │       │                                                               │
│             all │ 73    │ DEFAULT_TITLE: All Posts                                      │
│                 │       │ title: All Markata Modules                                    │
│                 │       │ slug: all                                                     │
│                 │       │ name: all                                                     │
│                 │       │ filter: True                                                  │
│                 │       │ sort: date                                                    │
│                 │       │ reverse: False                                                │
│                 │       │ rss: True                                                     │
│                 │       │ sitemap: True                                                 │
│                 │       │ card_template: card.html                                      │
│                 │       │ template: feed.html                                           │
│                 │       │ rss_template: rss.xml                                         │
│                 │       │ sitemap_template: sitemap.xml                                 │
│                 │       │ xsl_template: rss.xsl                                         │
│                 │       │                                                               │
│    core_modules │ 17    │ DEFAULT_TITLE: All Posts                                      │
│                 │       │ title: Markata Core Modules                                   │
│                 │       │ slug: core_modules                                            │
│                 │       │ name: core_modules                                            │
│                 │       │ filter: 'plugin' not in slug and 'test' not in slug and ti... │
│                 │       │ sort: date                                                    │
│                 │       │ reverse: False                                                │
│                 │       │ rss: True                                                     │
│                 │       │ sitemap: True                                                 │
│                 │       │ card_template: card.html                                      │
│                 │       │ template: feed.html                                           │
│                 │       │ rss_template: rss.xml                                         │
│                 │       │ sitemap_template: sitemap.xml                                 │
│                 │       │ xsl_template: rss.xsl                                         │
│                 │       │                                                               │
│         plugins │ 42    │ DEFAULT_TITLE: All Posts                                      │
│                 │       │ title: Markata Plugins                                        │
│                 │       │ slug: plugins                                                 │
│                 │       │ name: plugins                                                 │
│                 │       │ filter: 'plugin' in slug and 'test' not in slug               │
│                 │       │ sort: date                                                    │
│                 │       │ reverse: False                                                │
│                 │       │ rss: True                                                     │
│                 │       │ sitemap: True                                                 │
│                 │       │ card_template: card.html                                      │
│                 │       │ template: feed.html                                           │
│                 │       │ rss_template: rss.xml                                         │
│                 │       │ sitemap_template: sitemap.xml                                 │
│                 │       │ xsl_template: rss.xsl                                         │
│                 │       │                                                               │
└─────────────────┴───────┴───────────────────────────────────────────────────────────────┘
```

## 0.8.0

- pydantic support

### Pydantic Support

Now plugins are configured through a pydantic Config object.

### breaking changes

There are a number of breaking changes going into 0.8.0. Use caution when
upgrading.

#### glob config is now under markata.glob

```diff
- [markata]
- glob_patterns = "pages/**/*.md"
+ [markata.glob]
+ glob_patterns = "pages/**/*.md"
```

#### Feeds are now a list

Feeds are now a list of Objects within the configuration that you choose from
whether its toml or yaml.  Also templates_dir is now configurable, and once you
have a templates dir it is better to specify templates by name relative to your
templates_dir.

```toml
[markata]
templates_dir = "pages/templates"

[markata.feeds.published]
template="archive_template.html"
card_template = "feed_card.html"
filter="date<=today and templateKey in ['blog-post', 'til'] and status.lower()=='published'"
sort="date"
```

> old

```toml
[[markata.feeds.published]]
template="pages/templates/archive_template.html"
card_template = "pages/templates/feed_card.html"
filter="date<=today and templateKey in ['blog-post', 'til'] and status.lower()=='published'"
sort="date"
```

> new

### markata.summary.filter_count is now a list

The old way was to set up a dict, where the keys were the name, now its a list
of Objects with an explicit name field.

```toml
[markata.summary.filter_count.drafts]
filter="published == 'False'"
color='red'
```

> Old

```toml
[[markata.summary.filter_count]]
name='drafts'
filter="published == 'False'"
color='red'
```

## 0.7.4

- Fix: Icon resize broken from PIL 10.0.0 release

## 0.7.3

- Fix: broken default feed card template
- Fix: broken links for index.md in feeds

## 0.7.2

- Fix: broken `markata new` command due to pydantic v2 compatability with copier.

## 0.7.0

- Adopt ruff linter 0.7.0.dev1 #142
- add support for markdown_it_py backend #145
- add trogon tui support 0.7.0.dev6

### trogon tui support

install with pip

```bash
pip install 'markata[tui]'
```

usage

```bash
markata tui
```

## 0.6.4

- Fix: Icon resize broken from PIL 10.0.0 release

## 0.6.3

- Fix: broken `markata new` command due to pydantic v2 compatability with copier.

## 0.6.2

Update License and Security files.

## 0.6.1

- Fix: allow feeds to be used from within Markdown.

### Feeds in Markdown

```markdown
{% for post in markata.feeds.docs.posts %}
[{{post.title}}](/{{post.slug}})
{% endfor %}
```

## 0.6.0

- Fix: article_html is not available to jinja 0.6.0.dev1 #105
- Fix: service worker is not upating client without hard refresh 0.6.0.dev2
  #106
- Feat: create teardown lifecycle method 0.6.0.dev3 #110
- Fix: implement teardown on all raises 0.6.0.dev4 #111
- Fix: implement teardown in pyinstrument plugin 0.6.0.dev5 #112
- Feat: Automatically call teardown without needing to remember it before raise
  0.6.0.dev6 #113
- Fix: only stop the profiler if it is running 0.6.0.dev7 #114
- Fix: map was giving inconsistent results 0.6.0.dev8 #116
- Fix: tui continuously rebuilds if an input file exists in a parent directory
  to the output directory 0.6.0.dev9 #118
- Feat: report the cache stats for the current run 0.6.0.dev11 #121
- Fix: prevent zerodivisionerror when reporting stats 0.6.0.dev12 #122
- Fix: properly set the pyinstrument profiler to prevent recurrsion errors
  0.6.dev13 #123
- Clean: cli attributes (`runner`, `summary`, `server`, `plugins`) are now
  added as Markata properties through `register_attr` rather than directly to
  the class 0.6.0.dev13 #107
- Fix: Markata tui will remain running even when the runner fails 0.6.0.dev13
  #107
- Fix: Pinned to `textual<0.2.0` due to breaking changes 0.6.0.dev13 #107
- Fix: snyk remove seuptools from requirements 0.6.0.dev14 #130
- Fix: Markata.filter was missing post and m 0.6.0.dev14 #133
- Feat: add `path_prefix` config for gh-pages deploy 0.6.0.dev15 #132 fixes #57
- Feat: created `markata plugin show` cli command 0.6.0.dev16 #109
- Feat: use `path_prefix` in nav entries 0.6.0.dev17 #136
- Feat: enable wikilinks extension by default 0.6.0.dev18 #138
- Feat: `markata` instance is available form inside card_template for feeds
  0.6.0.dev19 #139

### wikilinks

wikilinks are now enabled by default ex: `[[home-page]]`. This will create a
link `<a class="wikilink" href="/home-page/">home-page</a>`. This will
automagically work if you leave `markata.plugins.flat_slug` plugin enabled
(which is by default).

> ProTip: this was highly inspired by the
> [marksman-lsp](https://github.com/artempyanykh/marksman) by
> [artempyanykh](https://github.com/artempyanykh/), which can autocomplete post
> links in this style for you.

[[home-page]]

## 0.5.5

- Fix: Icon resize broken from PIL 10.0.0 release

## 0.5.4

- Fix: broken `markata new` command due to pydantic v2 compatability with copier.

## 0.5.2

- clean up unnecessary images_url is missing warning #104 0.5.2.dev1

## 0.5.1

- fix: contrast ratio on admonitions was insufficient for A11y #103 0.5.1.dev0

## 0.5.0

- Create `new` cli command for creating new `blogs`, `posts`, and `plugins` #93
  0.5.0.dev16 [base_cli-docs](https://markata.dev/markata/plugins/base_cli/)
- Remove unused function clif that was the original entrypoint #81 0.5.0.dev8
- Allow template variables to be used in head config #88 0.5.0.dev12
- Expose `markata.__version__` to templates as `__version__` #89 0.5.0.dev13
- Fix, ignore post_template save on posts without an html attribute #92 0.5.0.dev13
- Fix #33 sluggify paths #69 **BREAKING CHANGE** 0.5.0.dev6
- Configurable template #70 0.5.dev5, #85 0.5.0.dev11
- Fix #40 Images overlfow outside of body #66 0.5.0.dev3
- Created entrypoint hook allowing for users to extend marka with jinja
  exensions #60 0.5.0.dev2
- Moved to PEP 517 build #59 0.5.0.dev1
- new `markata.plugins.redirects` will create redirect html files as a backup when
  server-side redirects fail. #76 0.5.0.dev10
  [redirects-docs](https://markata.dev/markata/plugins/redirects/)
- create a slugify migration script #82
- DeepMerge `config_overrides` with config in post render methods #91 0.5.0.dev13
- Create ipython extension to automatically load markata #79 0.5.0.dev15
- Fix: images wrapped in a link overflow outside the body #96
- new `markata.plugins.service_worker` plugin to create service workers and
  enable offline mode on sites #94 0.5.0.dev15
  [service-worker-docs](https://markata.dev/markata/plugins/service-worker/)
- Fix: icons were relatively linked, and were broken for any page other than
  index, they are now absolutely linked to the root of the site. #97 0.5.0.dev16
- Fix: auto_descriptions were not rendered on first pass in tui or at all in
  build due to auto_description running after jinja_md. #100 0.5.0.dev18
- Fix: give redirect pages a uniqe description and title #101 0.5.0.dev19

### `new` cli command

More information in the [base_cli-docs](https://markata.dev/markata/plugins/base_cli/).

```bash
# create a new blog template
# copier requires you to specify a directory
markata new blog [directory]

# create a new blog post
markata new post

# create a new plugin
markata new plugin

markata new --help

 Usage: markata new [OPTIONS] COMMAND [ARGS]...

 create new things from templates

╭─ Options ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ --help          Show this message and exit.                                                                                                                                       │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─ Commands ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ blog       Create a new blog from using the template from https://github.com/WaylonWalker/markata-blog-starter.                                                                   │
│ plugin     Create a new plugin using the template at https://github.com/WaylonWalker/markata-plugin-template.                                                                     │
│ post       Create new blog post in the pages directory from the template at  https://github.com/WaylonWalker/markata-post-template.                                               │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
```

### sluggify paths

`python-sluggify` was implemented to ensure good urls are in place despite the
name of the original file.

For examples of how `python-slugify` will change your url's see the
[project's home page](https://pypi.org/project/python-slugify/). One
difference is that `markata` will leave `/`'s for routing in the slugs.

#### OPTING OUT

If you have an existing site and do not want to implement redirects or if you
do not want to use slugify, you can opt out by setting `slugify=False` in your
`markata.toml`.

```toml
[markata]
slugify=false
```

#### Migrating to slugify

From the command line with `markata>=0.5.0` installed run the
migration script from the command line to create a redirects file in the
default location. This should avoid all 404's as it will create a redirects
file that many static hosting providers will issue a server-side 301 for, and
for those that don't, markata.plugins.redirects creates a redirect html page,
that will kick in as a backup.

```bash
python -m markata.scripts.migrate_to_slugify
```

### configurable page template

Now injects seo into the default template through configuration. Here is an
example, by adding this to your `markata.toml` configuration.

```toml
[[markata.head.meta]]
name = "og:type"
content = "article"

[[markata.head.meta]]
name = "og:author"
content = "Waylon Walker"

[[markata.head.meta]]
name = "og:site_name"
content = "Waylon Walker"

[[markata.head.meta]]
name = "theme-color"
content="#322D39"

[[markata.head.meta]]
name = "twitter:creator"
content="@_waylonwalker"
```

You will end up with these meta tags in your html.

```html
<meta name="og:type" content="article" />
<meta name="og:author" content="Waylon Walker" />
<meta name="og:site_name" content="Waylon Walker" />
<meta name="theme-color" content="#322D39" />
<meta name="twitter:creator" content="@_waylonwalker" />
```

You can have an array of toml tables with a key of text. The text will be
added as plain text to the end of the head of each page.

```toml
[[markata.head]]
text = """
<style>
img {
width: 100%;
height: auto;
}
ul {
  display: flex;
  flex-wrap: wrap;
}

li {
  flex: 1 2 400px;
}
</style>

"""
```

Descriptions will now properly end up in each page.

```html
<meta name="description" content="{{ description }}" />
```

## Config Overrides

Each post can override config settings such as `head`. New meta tags can be
added to a single post, or anything that your template might reference from
config.

```yaml
config_overrides:
  head:
    meta:
      - content: waylonwalker
        name: author
      - content: "@_waylonwalker"
        name: "twitter:creator"
    link:
      - href: https://waylonwalker.com/that-special-post/
        rel: canonical
    text:
      - value: <link rel='stylesheet' href='/my-extra-styles.css' />
```

## ipython extension

Markata has an ipython extension if you want ipython to automatically load with
an instance of `Markata` mapped to `m` and `markata` you can add the following
to your `~/.ipython/profile_default/ipython_config.py`

```python
c.InteractiveShellApp.extensions.append('markata')
```

## 0.4.1

- Issue FutureWarning for upcoming change to slugify change that will change urls

To keep existing behavior add this to your `markata.toml`.

```toml
[markata]
slugify=false
```

## 0.4.0

- feat: add html logging with [setup_logging](/markata/plugins/setup_logging/)
  plugin is all new closes #37
- fix: remove HTML tidy as the site generator tag
- feat: create configurable [navbar](https://markata.dev/nav)
- perf: prevent double runs on pre-render and post-render #39
- perf: prevent duplicate ruun from to_dict calling pre-render #53
  - `to_dict` only runs up to `render` phase if necessary as directed by `register_attr`
- perf: only prettify if configured #54
- fix: pyinstrument will not create a second profiler causing it to end in
  errors #50
- fix: sites without feeds config do not create an index #55

### Double Runs

Previously markata would catch AttributeError and run the previous step any
time you ran a step too early. The way this was implemented caused some steps
such as pre-render and post-render to run twice with every single run.

This change will no longer catch attribute errors. If you run into any issues
with your plugins not running before asking for attributes created by your
plugin make sure that you implement the
[@register_attr](https://markata.dev/markata/hookspec/#register_attr-function)
decorator.

### Prettify

prettify html has been turned off by default as beautifulsoup4 prettify was
taking a significant time, and was often popping up as the slowest parts in my
personal `_profile`. If you want to continue running prettify throughout the
build you can set a flag in your config to continue running prettify.

```toml
[markata]
prettify_html = true
```

## 0.3.0

Skipped from a bump2version misconfiguration.

## 0.2.0

- feat: [auto_description](/markata/plugins/auto_description/) plugin is all
  new closes #13
- deprecated: long_description has been deprecated by auto_description
- fix: [covers](/markata/plugins/covers/) plugin would previously skip
  every time.
- feat: [`markata clean`](/markata/plugins/base_cli/#clean-function) cleans up
  your cache and output from the command line
- fix: [`publish_source`](/markata/plugins/publish_source/) plugin will now
  ignore any non yaml serializable values
- feat: Default template colors are now customizable
- feat: Default template now has light and dark theme
- feat: map now can map entire posts
- feat: [prevnext](/markata/plugins/prevnext/) plugin was added to link between
  posts closes #20
- feat: [jinja_md](/markata/plugins/jinja_md/) plugins was added to incorporate
  jinja into all the markdown
- breaking: [feeds](/markata/plugins/feeds) config now has feeds and
  feeds_config
- feat: `output_html` can now be specified in the frontmatter
  [see example](/markata/plugins/publish_html/#explicityly-set-the-output)
- feat: edit link is now included in the default page template closes #21

### breaking change to feeds config

If you are using the 0.1.0 version of feeds, and have configured custom
templates in `markata.feeds.template` and `markata.feeds.card_template` they
will need to be moved to `markata.feeds_config`.

Here is what you need to do to update your feeds_config.

```diff
+ [markata.feeds_config]
+ template="pages/templates/archive_template.html"
+ card_template="plugins/feed_card_template.html"
- [markata.feeds]
- template="pages/templates/archive_template.html"
- card_template="plugins/feed_card_template.html"
```

`markata.feeds` will only be used to configure feeds pages.

### map entire posts

`post` is now exposed to the `markata.map` object, allowing you to return a
list of posts.

```python
m = Markata()
# 'post' will return the entire post
m.map('post', filter='"git" in tags')
```

### Customizable colors

```toml
[markata]
# default dark theme
color_bg = '#1f2022'
color_bg_code = '#1f2022'
color_text = '#eefbfe'
color_link = '#47cbff'
color_accent = '#e1bd00c9'
overlay_brightness = '.85'

# pink and purple
color_bg = 'deeppink'
color_bg_code = 'rebeccapurple'
color_text = 'white'
color_link = 'aqua'
color_accent = 'peachpuff'
overlay_brightness = '1.2'

# default light theme
color_bg_light = '#eefbfe'
color_bg_code_light = '#eefbfe'
color_text_light = '#1f2022'
color_link_light = '#47cbff'
color_accent_light = '#ffeb00'
overlay_brightness_light = '.95'
```

### All New auto_description plugin

- Cache is busted on plugin change
- plugin is configurable
- plugin now has docs

### auto_description Configuration

Open up your `markata.toml` file and add new entries for your
auto_descriptions. You can have multiple desriptions, each one will be named
after the key you give it in your config.

```toml
[markata]
hooks=[
   "markata.plugins.auto_description",
   ]

[markata.auto_description.description]
len=160
[markata.auto_description.long_description]
len=250
[markata.auto_description.super_description]
len=500
```

In the above we will end up with three different descritpions,
(`description`, `long_description`, and `super_description`) each will be the
first number of characters from the document as specified in the config.

### auto_descriptions are no longer duplicated

4e299d6 fixes the dedupe issue that was in develop for a while and closes #24

## 0.1.0

- fix: pyinstument plugin no longer overrides the main cli callback
- feat: default is to run the profiler if pyinstrument is installed
- fix: --profile is now under the build command
- feat: --pretty/--no-pretty will make pretty tracebacks, and skip over
  framework code (closes #4 )
- fix: links are now absolute, so they work from GitHub, thanks
  [MR Destructive](https://github.com/Mr-Destructive)
- deprecate: `article['content_hash']` has been removed with preference for
  hashing on `article['content']`
- create `heading_link` plugin
- doc: How to create your home page. [docs](/home-page/)

### New cli help

After the pyinstrument plugin was fixed --version and --to-json are back, and
--profile is now under the build command.

![image](https://user-images.githubusercontent.com/22648375/150662983-547aebbd-c18c-4c17-8985-a6dc01cd29c7.png)

### New Heading Link Plugin

The new heading link plugin makes it easier to share the exact part of an
article you want with someone, by giving clickable links to the id of the
heading it's next to.

![image](https://user-images.githubusercontent.com/22648375/151718782-08a7cd26-41c1-4f00-a12c-0a208c593e9c.png)

## 0.0.1

Initial Release
    ]]></content>
  </entry>
  <entry>
    <title>Markata&#39;s Docs</title>

    <id>https://markata.dev/markata-dev/</id>
    <link href="https://markata.dev/markata-dev/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
Markta.dev home page Markata builds it's own docs in completely in using all built in templatates and plugins. Markta.dev home page Using the plugin it is…
    ]]></summary>

    <content type="html"><![CDATA[
[![Markta.dev home page](/markata.dev_.webp)](https://markata.dev){.shadow-2xl}

Markata builds it's own docs in completely in `markata` using all built in
templatates and plugins.

[![Markta.dev home page](/markata.dev_markata_plugins_base-cli_.webp)](https://https://markata.dev/markata/plugins/base-cli/){.shadow-2xl}

Using the `markata.plugins.docs` plugin it is able to load all the python
files.  It renders out all the docstrings as markdown and shows the code in
highlighted code blocks.
    ]]></content>
  </entry>
  <entry>
    <title>Theming your markata site</title>

    <id>https://markata.dev/color-theme/</id>
    <link href="https://markata.dev/color-theme/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
Default colors The default markata page template support the following colors to be configured in the file. There are two sets of similarly named colors, one…
    ]]></summary>

    <content type="html"><![CDATA[
## Default colors

The default markata page template support the following colors to be configured
in the `markata.toml` file. There are two sets of similarly named colors, one
for light theme and one for dark.  The default page template will set these
colors based on the users `prefers-color-scheme`.

```toml
[markata]
color_bg = '#1f2022'
color_bg_code = '#1f2022'
color_text = '#eefbfe'
color_link = '#47cbff' 
color_accent = '#e1bd00c9'
overlay_brightness = '.85'

color_bg_light = '#eefbfe'
color_bg_code_light = '#eefbfe'
color_text_light = '#1f2022'
color_link_light = '#47cbff' 
color_accent_light = '#ffeb00'
overlay_brightness_light = '.95'
```

## Pink and Purple

```toml
[markata]
color_bg = 'deeppink'
color_bg_code = 'rebeccapurple'
color_text = 'white'
color_link = 'aqua' 
color_accent = 'peachpuff'
overlay_brightness = '1.2'
```

## Changing your favicon

Your favicon should be kept in your `assets` directory, which is `./static` by
default.  You can name the icon what you want, `icon.png` is the default, but
you will have to change your icon config in your `markata.toml` to use a
different value.

``` toml
[markata]
assets_dir = "static"
icon = "icon.png"
```
    ]]></content>
  </entry>
  <entry>
    <title>Admonitions</title>

    <id>https://markata.dev/admonitions/</id>
    <link href="https://markata.dev/admonitions/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
all of the admonitions
    ]]></summary>

    <content type="html"><![CDATA[
???+ note open by default
    you can open a details tab with '+'

``` markdown
???+ note open by default
    you can open a details tab with '+'
```

!!! important
    inside of admonitions need four leading spaces.


??? note closed by default
    you can open a details tab with '+'

``` markdown
??? note closed by default
    you can open a details tab with '+'
```

## all of the admonitions

!!! note
    a note

``` markdown
!!! note
    a note
```

!!! abstract
    an abstract

``` markdown
!!! abstract
    an abstract
```

!!! info
    admonitions

``` markdown
!!! info
    admonitions
```

!!! tip
    You should think about using admonitions

``` markdown
!!! tip
    You should think about using admonitions
```

!!! success
    Run Successful!

``` markdown
!!! success
    Run Successful!
```

!!! question
    What do you think of this?

``` markdown
!!! question
    What do you think of this?
```

!!! source
    Add some source code.
    ```python
    print('hello world')

``` markdown
!!! source
    Add some source code.
    ```python
    print('hello world')
```
    ]]></content>
  </entry>
  <entry>
    <title>__main__.py</title>

    <id>https://markata.dev/markata/main/</id>
    <link href="https://markata.dev/markata/main/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
None
    ]]></summary>

    <content type="html"><![CDATA[
---

None

---
    ]]></content>
  </entry>
  <entry>
    <title>__init__.py</title>

    <id>https://markata.dev/markata/init/</id>
    <link href="https://markata.dev/markata/init/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
Markata is a tool for handling directories of markdown.
    ]]></summary>

    <content type="html"><![CDATA[
---

Markata is a tool for handling directories of markdown.

---

!!! method
    <h2 id="teardown" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">teardown <em class="small">method</em></h2>

    Cleanup and print statistics when Markata is done.

???+ source "teardown <em class='small'>source</em>"
    ```python
    def teardown(self: "Markata"):
            """Cleanup and print statistics when Markata is done."""
            # Print map cache statistics if they exist
            if hasattr(self, "_map_cache_stats"):
                stats = self._map_cache_stats
                total = stats["total"]
                if total > 0:
                    hit_rate = (stats["hits"] / total) * 100
                    self.console.print("\n[yellow]Map Cache Statistics:[/yellow]")
                    self.console.print(f"Total calls: {total}")
                    self.console.print(f"Cache hits: {stats['hits']}")
                    self.console.print(f"Cache misses: {stats['misses']}")
                    self.console.print(f"Hit rate: {hit_rate:.1f}%")
                    self.console.print(
                        f"Cache size: {len(getattr(self, '_filtered_cache', {}))}"
                    )
            if self.stages_ran:
                self._pm.hook.teardown(markata=self)
            return self
    ```
!!! method
    <h2 id="_compile_sort_key" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">_compile_sort_key <em class="small">method</em></h2>

    Compile a sort key function for better performance

???+ source "_compile_sort_key <em class='small'>source</em>"
    ```python
    def _compile_sort_key(self, sort: str):
            """Compile a sort key function for better performance"""
            if "datetime" in sort.lower():
                return lambda a: a.get(sort, datetime.datetime(1970, 1, 1))
            if "date" in sort.lower():
                return lambda a: a.get(sort, datetime.date(1970, 1, 1))

            # Create a compiled function for complex sort expressions
            try:
                code = compile(sort, "<string>", "eval")

                def sort_key(a):
                    try:
                        value = eval(code, a.to_dict(), {})
                        if isinstance(value, (int, float)):
                            return value
                        if hasattr(value, "timestamp"):
                            return value.timestamp()
                        if isinstance(value, datetime.date):
                            return datetime.datetime.combine(
                                value,
                                datetime.datetime.min.time(),
                            ).timestamp()
                        return sum(ord(c) for c in str(value))
                    except Exception:
                        return -1

                return sort_key
            except Exception:
                return lambda _: -1
    ```
!!! method
    <h2 id="_get_sort_key" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">_get_sort_key <em class="small">method</em></h2>

    Cache compiled sort key functions

???+ source "_get_sort_key <em class='small'>source</em>"
    ```python
    def _get_sort_key(self, sort: str):
            """Cache compiled sort key functions"""
            return self._compile_sort_key(sort)
    ```
!!! method
    <h2 id="_get_eval_globals" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">_get_eval_globals <em class="small">method</em></h2>

    Get common globals used in eval operations

???+ source "_get_eval_globals <em class='small'>source</em>"
    ```python
    def _get_eval_globals(self):
            """Get common globals used in eval operations"""
            if not hasattr(self, "_eval_globals"):
                self._eval_globals = {"timedelta": timedelta}
            return self._eval_globals
    ```
!!! method
    <h2 id="_eval_with_article" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">_eval_with_article <em class="small">method</em></h2>

    Evaluate code with article context, reusing dict where possible

???+ source "_eval_with_article <em class='small'>source</em>"
    ```python
    def _eval_with_article(self, code, article, extra_globals=None):
            """Evaluate code with article context, reusing dict where possible"""
            if not hasattr(article, "_eval_dict"):
                article._eval_dict = article.to_dict()
                article._eval_dict.update({"post": article, "m": self})

            globals_dict = self._get_eval_globals()
            if extra_globals:
                globals_dict.update(extra_globals)

            try:
                return eval(code, article._eval_dict, globals_dict)
            except Exception:
                return None
    ```
    ]]></content>
  </entry>
  <entry>
    <title>Manually create a new site</title>

    <id>https://markata.dev/create-manual/</id>
    <link href="https://markata.dev/create-manual/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
Markata has some templates that let you get up and running quickly, but you can make a site with only markdown if you wanted. Installation is hosted on pypi…
    ]]></summary>

    <content type="html"><![CDATA[
Markata has some templates that let you get up and running quickly, but you
_can_ make a site with only markdown if you wanted.

## Installation

`markata` is hosted on pypi and can be installed using pip.

```bash
python -m pip install markata

# or if pipx is your thing

pipx install markata
```

## Create Some Content

Make some `.md` files in your current working directory. By default, `markata`
will recursively look in all subdirectories for markdown files `**/*.md`.

```bash
mkdir pages
echo '# My First Post' > first-post.md
echo '# Hello World' > hello-world.md
```

> This example shows how you can build a site from only a single markdown
> file.

## Build your site

Install markata into your virtual environment and run `markata build`. It will
create your site in `./markout`, leave its cache in `./.markata.cache`, and
copy all assets from `./static` into `./markout` by default.

```bash
python -m pip install markata
markata build

# or if pipx is your thing
pipx run markata build
```
    ]]></content>
  </entry>
  <entry>
    <title>WaylonWalker.com</title>

    <id>https://markata.dev/waylonwalker/</id>
    <link href="https://markata.dev/waylonwalker/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
Waylonwalker.com home page This Waylon Walker's personal blog where he is learning in public. Posting about topics such as linux, vim, python, and kedro.…
    ]]></summary>

    <content type="html"><![CDATA[
[![Waylonwalker.com home page](/waylonwalker.com.webp)](https://waylonwalker.com)

This Waylon Walker's personal blog where he is learning in public.  Posting
about topics such as linux, vim, python, and kedro.  Flexing just a bit, after
writing content on the domain since 2017 it is achieving  15K clicks from
google every 28 days, 36 top 3 ranked keywords, and 2,400 top 10 ranked keywords.


[![Waylonwalker.com post](/waylonwalker.com_markata-configure-head.webp)](https://waylonwalker.com/markata-configure-head/)

A typical post has a header that is screenshot as the og image for display on
social platforms using selenium.  The overall theme holds similar to the home
and feeds pages.  With a large dark background image of repeating W's.


[![Waylonwalker.com feed](/waylonwalker.com_archive.webp)](https://waylonwalker.com/archive/)

Waylonwalker.com has several feeds running, but the most prominant one that is
shared in the navigation bar is the
[archive](https://waylonwalker.com/archive).  The feed itself has an RGB
backlight inspired yellow and purple glow around it.
    ]]></content>
  </entry>
  <entry>
    <title>__about__.py</title>

    <id>https://markata.dev/markata/about/</id>
    <link href="https://markata.dev/markata/about/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
None
    ]]></summary>

    <content type="html"><![CDATA[
---

None

---
    ]]></content>
  </entry>
  <entry>
    <title>errors.py</title>

    <id>https://markata.dev/markata/errors/</id>
    <link href="https://markata.dev/markata/errors/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
None
    ]]></summary>

    <content type="html"><![CDATA[
---

None

---

!!! class
    <h2 id="MarkataConfigError" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">MarkataConfigError <em class="small">class</em></h2>

    raise when markata is unable to configure correctly

???+ source "MarkataConfigError <em class='small'>source</em>"
    ```python
    class MarkataConfigError(ValueError):
        """
        raise when markata is unable to configure correctly
        """
    ```
    ]]></content>
  </entry>
  <entry>
    <title>cli.py</title>

    <id>https://markata.dev/markata/cli/cli/</id>
    <link href="https://markata.dev/markata/cli/cli/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
None
    ]]></summary>

    <content type="html"><![CDATA[
---

None

---

!!! function
    <h2 id="make_layout" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">make_layout <em class="small">function</em></h2>

    Define the layout.

???+ source "make_layout <em class='small'>source</em>"
    ```python
    def make_layout() -> Layout:
        """Define the layout."""
        layout = Layout(name="root")

        layout.split(
            Layout(name="header", size=3),
            Layout(name="main"),
        )
        layout["main"].split_row(
            Layout(name="side", ratio=50),
            Layout(name="mid", ratio=30),
            Layout(name="describe", ratio=20),
        )
        layout["mid"].split(
            Layout(name="server"),
            Layout(name="runner"),
        )
        layout["side"].split(
            Layout(name="plugins"),
        )
        return layout
    ```
    ]]></content>
  </entry>
  <entry>
    <title>Using Multiple Templates</title>

    <id>https://markata.dev/multi-template/</id>
    <link href="https://markata.dev/multi-template/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
This page will be rendered multiple times. This is the normal page, check out title . It uses the og.html template. This is achieved through the use of the…
    ]]></summary>

    <content type="html"><![CDATA[
This page will be rendered multiple times.  This is the normal page, check out
[title](./title). It uses the og.html template.  This is achieved through the
use of the template option in the frontmatter.

``` md
---
title: Using Multiple Templates
description: Guide to using multiple templates in markata
jinja: false
template:
  index: post.html
  title: og.html


---
```
    ]]></content>
  </entry>
  <entry>
    <title>__main__.py</title>

    <id>https://markata.dev/markata/cli/main/</id>
    <link href="https://markata.dev/markata/cli/main/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
None
    ]]></summary>

    <content type="html"><![CDATA[
---

None

---
    ]]></content>
  </entry>
  <entry>
    <title>__init__.py</title>

    <id>https://markata.dev/markata/cli/init/</id>
    <link href="https://markata.dev/markata/cli/init/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
None
    ]]></summary>

    <content type="html"><![CDATA[
---

None

---
    ]]></content>
  </entry>
  <entry>
    <title>test_feeds.py</title>

    <id>https://markata.dev/tests/test-feeds/</id>
    <link href="https://markata.dev/tests/test-feeds/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
None
    ]]></summary>

    <content type="html"><![CDATA[
---

None

---
    ]]></content>
  </entry>
  <entry>
    <title>hookspec.py</title>

    <id>https://markata.dev/markata/hookspec/</id>
    <link href="https://markata.dev/markata/hookspec/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
Markata's hook specification system for plugin development. Overview Markata uses pluggy to define hooks that plugins can implement. These hooks allow plugins…
    ]]></summary>

    <content type="html"><![CDATA[
---

Markata's hook specification system for plugin development.

## Overview

Markata uses pluggy to define hooks that plugins can implement. These hooks allow plugins
to modify Markata's behavior at specific points in the build process.

## Hook Types

### Configuration Hooks

Used to set up plugin configuration and models:

```python
from markata.hookspec import hook_impl, register_attr

@hook_impl
@register_attr("config")
def config_model(markata):
    """Add plugin-specific config."""
    from pydantic import BaseModel

    class MyConfig(BaseModel):
        enabled: bool = True
        output_file: str = "output.html"

    return {"my_plugin": MyConfig()}

@hook_impl
@register_attr("my_data")
def configure(markata):
    """Initialize plugin using config."""
    if markata.config.my_plugin.enabled:
        # Set up plugin resources
        markata.my_data = []
```

## Content Model Hooks

Define how content is structured:

```python
@hook_impl
@register_attr("post_models")
def post_model(markata):
    """Add fields to post model."""
    from pydantic import BaseModel, Field

    class MyPostFields(BaseModel):
        custom_date: str = Field(None, description="Custom date field")
        tags: list[str] = Field(default_factory=list)

    return MyPostFields
```

## Content Processing Hooks

Handle content transformation:

```python
@hook_impl(trylast=True)  # Run after other render hooks
def render(markata):
    """Process each article."""
    for article in markata.filter("not skip"):
        # Add custom processing
        if article.tags:
            article.tag_links = [f"<a href='/tags/{tag}'>{tag}</a>"
                               for tag in article.tags]
```

## Output Generation Hooks

Control how content is saved:

```python
@hook_impl
def save(markata):
    """Save processed content."""
    output_dir = Path(markata.config.output_dir)

    # Save custom index
    if markata.config.my_plugin.enabled:
        index = generate_custom_index(markata.articles)
        (output_dir / "custom.html").write_text(index)
```

## Hook Ordering

Control execution order with decorators:

```python
# Run first in configure stage
@hook_impl(tryfirst=True)
def configure(markata): ...

# Run in middle (default)
@hook_impl
def configure(markata): ...

# Run last in configure stage
@hook_impl(trylast=True)
def configure(markata): ...
```

## Attribute Registration

Register data on the Markata instance:

```python
# Single attribute
@register_attr("articles")
def my_hook(markata):
    markata.articles = []

# Multiple attributes
@register_attr("articles", "tags", "categories")
def my_hook(markata):
    markata.articles = []
    markata.tags = {}
    markata.categories = {}

# Access in other hooks
@hook_impl
def render(markata):
    print(markata.articles)  # Access registered data
```

## Complex Example

Here's a complete plugin example combining multiple hooks:

```python
from pathlib import Path
from typing import List, Optional
from pydantic import BaseModel, Field
from markata.hookspec import hook_impl, register_attr

class TagConfig(BaseModel):
    """Configuration for tag handling."""
    enabled: bool = True
    min_posts: int = 2
    output_dir: str = "tags"

class TaggedPost(BaseModel):
    """Add tag fields to posts."""
    tags: List[str] = Field(default_factory=list)
    tag_links: Optional[str] = None

@hook_impl
@register_attr("config_models")
def config_model(markata):
    """Add tag configuration."""
    markata.config_models.append(TagConfig)

@hook_impl
@register_attr("post_models")
def post_model(markata):
    """Add tag fields to posts."""
    markata.post_models.append(TaggedPost)


@hook_impl(trylast=True)
def render(markata):
    """Add tag links to articles."""
    if not markata.config.tags.enabled:
        return

    for article in markata.filter("not skip"):
        article.tag_links = " ".join(
            f"<a href='/tags/{tag}'>{tag}</a>"
            for tag in article.tags
        )

@hook_impl
def save(markata):
    """Generate tag pages."""
    if not markata.config.tags.enabled:
        return

    output_dir = Path(markata.config.output_dir)
    tag_dir = output_dir / markata.config.tags.output_dir
    tag_dir.mkdir(exist_ok=True)

    for tag, articles in markata.tags.items():
        if len(articles) >= markata.config.tags.min_posts:
            content = generate_tag_page(tag, articles)
            (tag_dir / f"{tag}.html").write_text(content)
```

This example shows:
1. Configuration definition
2. Model extension
3. Data processing
4. Content generation
5. Output handling

See [[ markata/lifecycle ]] for the exact order hooks are executed.

---

!!! class
    <h2 id="MarkataSpecs" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">MarkataSpecs <em class="small">class</em></h2>

    Namespace that defines all specifications for Load hooks.

    configure -> glob -> load -> render -> save

???+ source "MarkataSpecs <em class='small'>source</em>"
    ```python
    class MarkataSpecs:
        """
        Namespace that defines all specifications for Load hooks.

        configure -> glob -> load -> render -> save
        """
    ```
!!! function
    <h2 id="cli_lifecycle_method" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">cli_lifecycle_method <em class="small">function</em></h2>

    A Markata lifecycle methos that includes a typer app used for cli's

???+ source "cli_lifecycle_method <em class='small'>source</em>"
    ```python
    def cli_lifecycle_method(markata: "Markata", app: "typer.Typer") -> Any:
        "A Markata lifecycle methos that includes a typer app used for cli's"
    ```
    ]]></content>
  </entry>
  <entry>
    <title>lifecycle.py</title>

    <id>https://markata.dev/markata/lifecycle/</id>
    <link href="https://markata.dev/markata/lifecycle/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The LifeCycle is a core component for the internal workings of Markata. It sets fourth the hooks available, the methods to run them on the Markata instance,…
    ]]></summary>

    <content type="html"><![CDATA[
---

The LifeCycle is a core component for the internal workings of Markata.  It
sets fourth the hooks available, the methods to run them on the Markata
instance, and the order they run in.

# Build Lifecycle

The build process follows these stages in order. Each stage runs all registered hooks
for that stage before proceeding to the next stage.

## 1. Configuration Stage

Sets up the build environment:


```python
# First: Define configuration models
# Example plugin:
from markata.hookspec import hook_impl

@hook_impl
def config_model(markata):
    markata.config_models.append(MyConfig)
```


``` python
# Second: Configure plugins
# Example plugin:
from markata.hookspec import hook_impl

@hook_impl
def configure(markata):
    markata.my_data = setup_resources()
```

## 2. Model Creation Stage

Defines content structure:

First: Define post model fragments

```python
from pydantic import BaseModel
from markata.hookspec import hook_impl

class MyPostFields(BaseModel):
    title: str
    tags: List[str]

# Example plugin:
@hook_impl
def post_model(markata):
    return MyPostFields
```

## 3. Content Discovery Stage

Finds and loads content:

```python
# First: Find content files
# Example plugin:
@hook_impl
def glob(markata):
    return list(Path("content").glob("**/*.md"))

# Second: Load content
# Example plugin:
@hook_impl
def load(markata):
    for path in markata.paths:
        content = path.read_text()
        markata.articles.append(parse_content(content))
```

## 4. Content Processing Stage

Transforms content:

```python
# Second: Convert markdown
# Example plugin:
@hook_impl
def render_markdown(markata):
    for article in markata.articles:
        article.html = convert_markdown(article.content)

# Third: Process content
# Example plugin:
@hook_impl
def render(markata):
    for article in markata.articles:
        article.html = apply_template(article.html)
```

## 5. Output Generation Stage

Saves processed content:

```python
# First: Save content
# Example plugin:
@hook_impl
def save(markata):
    for article in markata.articles:
        save_article(article)

# Finally: Clean up
# Example plugin:
@hook_impl
def teardown(markata):
    cleanup_resources()
```

# Hook Execution Order

Within each stage, hooks are executed in this order:
1. Hooks with tryfirst=True (earliest)
2. Hooks with no ordering specified
3. Hooks with trylast=True (latest)

Example ordering:
```python
@hook_impl(tryfirst=True)
def configure(markata):
    """Runs first in configure stage"""
    setup_required_resources()

@hook_impl
def configure(markata):
    """Runs in middle of configure stage"""
    setup_optional_features()

@hook_impl(trylast=True)
def configure(markata):
    """Runs last in configure stage"""
    finalize_configuration()
```

# Error Handling

The lifecycle manager handles errors in hooks:
1. Logs errors with traceback
2. Continues execution if possible
3. Raises fatal errors that prevent build

Example error handling:
```python
@hook_impl
def render(markata):
    try:
        process_content()
    except NonFatalError:
        # Log and continue
        markata.logger.warning("Non-fatal error in render")
    except FatalError:
        # Stop build
        raise
```

# Parallel Processing

Some stages support parallel execution:
- render_markdown: Parallel markdown conversion
- render: Parallel template rendering
- save: Parallel file writing

Example parallel hook:
```python
@hook_impl
def render_markdown(markata):
    with ThreadPoolExecutor() as executor:
        futures = []
        for article in markata.articles:
            future = executor.submit(convert_markdown, article.content)
            futures.append((article, future))

        for article, future in futures:
            article.html = future.result()
```

See [[ hookspec ]] for detailed hook specifications and standard_config.py for
configuration options.

### Usage

``` python
from markata import Lifecycle

step = Lifecycle.glob
```

---

!!! class
    <h2 id="LifeCycle" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">LifeCycle <em class="small">class</em></h2>

    LifeCycle currently supports the following steps.

    * config_model - load configuration models from plugins
    * post_model - load post models from plugins
    * create_models - merge models from all plugins into markata.Post and markata.Plugin
    * load_config - load configuration
    * configure - load and fix configuration
    * validate_config - validate configuration
    * glob - find files
    * load - load files
    * validate_posts
    * pre_render - clean up files/metadata before render
    * render - render content
    * post_render - clean up rendered content
    * save - store results to disk
    * teardown - runs on exit

???+ source "LifeCycle <em class='small'>source</em>"
    ```python
    class LifeCycle(Enum):
        """
        LifeCycle currently supports the following steps.

        * config_model - load configuration models from plugins
        * post_model - load post models from plugins
        * create_models - merge models from all plugins into markata.Post and markata.Plugin
        * load_config - load configuration
        * configure - load and fix configuration
        * validate_config - validate configuration
        * glob - find files
        * load - load files
        * validate_posts
        * pre_render - clean up files/metadata before render
        * render - render content
        * post_render - clean up rendered content
        * save - store results to disk
        * teardown - runs on exit

        """

        config_model = auto()
        post_model = auto()
        create_models = auto()
        load_config = auto()
        configure = auto()
        validate_config = auto()
        glob = auto()
        load = auto()
        pre_render = auto()
        render = auto()
        post_render = auto()
        save = auto()
        teardown = auto()

        def __lt__(self, other: object) -> bool:
            """
            Determine whether other is less than this instance.
            """
            if isinstance(other, LifeCycle):
                return self.value < other.value
            if isinstance(other, int):
                return self.value < other
            return NotImplemented

        def __eq__(self, other: object) -> bool:
            """
            Determine whether other is equal to this instance.
            """
            if isinstance(other, LifeCycle):
                return self.value == other.value
            if isinstance(other, int):
                return self.value == other
            return NotImplemented
    ```
!!! method
    <h2 id="__lt__" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">__lt__ <em class="small">method</em></h2>

    Determine whether other is less than this instance.

???+ source "__lt__ <em class='small'>source</em>"
    ```python
    def __lt__(self, other: object) -> bool:
            """
            Determine whether other is less than this instance.
            """
            if isinstance(other, LifeCycle):
                return self.value < other.value
            if isinstance(other, int):
                return self.value < other
            return NotImplemented
    ```
!!! method
    <h2 id="__eq__" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">__eq__ <em class="small">method</em></h2>

    Determine whether other is equal to this instance.

???+ source "__eq__ <em class='small'>source</em>"
    ```python
    def __eq__(self, other: object) -> bool:
            """
            Determine whether other is equal to this instance.
            """
            if isinstance(other, LifeCycle):
                return self.value == other.value
            if isinstance(other, int):
                return self.value == other
            return NotImplemented
    ```
    ]]></content>
  </entry>
  <entry>
    <title>header.py</title>

    <id>https://markata.dev/markata/cli/header/</id>
    <link href="https://markata.dev/markata/cli/header/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
None
    ]]></summary>

    <content type="html"><![CDATA[
---

None

---

!!! class
    <h2 id="Header" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">Header <em class="small">class</em></h2>

    Display header with clock.

???+ source "Header <em class='small'>source</em>"
    ```python
    class Header:
        """Display header with clock."""

        def __rich__(self) -> Panel:
            grid = Table.grid(expand=True)
            grid.add_column(justify="center", ratio=1)
            grid.add_column(justify="right")
            grid.add_row(
                "[magenta][b]Markata[/b][/] [bright_black]Live Server[/]",
                datetime.now().ctime(),
            )
            return Panel(grid, style="yellow")
    ```
    ]]></content>
  </entry>
  <entry>
    <title>server.py</title>

    <id>https://markata.dev/markata/cli/server/</id>
    <link href="https://markata.dev/markata/cli/server/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
None
    ]]></summary>

    <content type="html"><![CDATA[
---

None

---

!!! function
    <h2 id="find_port" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">find_port <em class="small">function</em></h2>

    Find a port not in ues starting at given port

???+ source "find_port <em class='small'>source</em>"
    ```python
    def find_port(port: int = 8000) -> int:
        """Find a port not in ues starting at given port"""
        import socket

        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            if s.connect_ex(("localhost", port)) == 0:
                return find_port(port=port + 1)
            return port
    ```
!!! function
    <h2 id="serve" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">serve <em class="small">function</em></h2>

    Serve the site locally.

???+ source "serve <em class='small'>source</em>"
    ```python
    def serve():
            """
            Serve the site locally.
            """
            run_server()
    ```
    ]]></content>
  </entry>
  <entry>
    <title>runner.py</title>

    <id>https://markata.dev/markata/cli/runner/</id>
    <link href="https://markata.dev/markata/cli/runner/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
None
    ]]></summary>

    <content type="html"><![CDATA[
---

None

---

!!! class
    <h2 id="Runner" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">Runner <em class="small">class</em></h2>

    Display Footer

???+ source "Runner <em class='small'>source</em>"
    ```python
    class Runner:
        """Display Footer"""

        _status = "waiting"
        status = "starting"
        last_error = ""
        title = "runner"
        border = "green"

        _dirhash = ""
        time = time.time()

        def __init__(self, markata: "Markata") -> None:
            self.m = markata
            self._dirhash = self.m.content_dir_hash
            self._run()
            atexit.register(self.kill)

        def kill(self) -> None:
            self.proc.stdout.close()
            self.proc.stderr.close()
            self.proc.kill()
            self.proc.wait()

        def run(self) -> None:
            "Runs the build only if one is not already running."
            if self.proc.poll() is not None:
                self._run()

        def _run(self) -> None:
            "Runs the build and sets the proc"
            self.status = "running"
            self.time = time.time()
            self.proc = subprocess.Popen(
                ["markata", "build"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
            )

        @property
        def status_message(self) -> str:
            "returns the status message to display"
            num_lines = self.m.console.height - 4
            last_error = "\n".join(self.last_error.split("\n")[-num_lines:])
            if self.status == "running":
                self.title = "runner running"
                self.border = "gold1"
            elif last_error == "":
                self.title = "runner succeded"
                self.border = "green"
            else:
                self.title = "runner failed"
                self.border = "red"
            self.title = f"{self.title} [blue]({round(time.time() - self.time)}s)[/]"

            return (
                f"runner is {self.status}"
                f"{round(time.time() - self.time)}\n"
                f"pid: {self.proc.pid}\n"
                f"hash: {self.m.content_dir_hash}\n"
                f"{last_error}"
            )

        def __rich__(self) -> Panel:
            if self.proc:
                if self.proc.poll() is None:
                    return Panel(
                        Text(self.status_message),
                        border_style=self.border,
                        title=self.title,
                        expand=True,
                    )

            if self.status == "running":
                self.status = "waiting"
                self.time = time.time()
                if self.proc:
                    self.last_error = self.proc.stderr.read().decode()

            if self._dirhash != self.m.content_dir_hash:
                self.run()
                self._dirhash = self.m.content_dir_hash

            return Panel(
                Text(self.status_message),
                border_style=self.border,
                title=self.title,
                expand=True,
            )
    ```
!!! method
    <h2 id="run" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">run <em class="small">method</em></h2>

    Runs the build only if one is not already running.

???+ source "run <em class='small'>source</em>"
    ```python
    def run(self) -> None:
            "Runs the build only if one is not already running."
            if self.proc.poll() is not None:
                self._run()
    ```
!!! method
    <h2 id="_run" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">_run <em class="small">method</em></h2>

    Runs the build and sets the proc

???+ source "_run <em class='small'>source</em>"
    ```python
    def _run(self) -> None:
            "Runs the build and sets the proc"
            self.status = "running"
            self.time = time.time()
            self.proc = subprocess.Popen(
                ["markata", "build"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
            )
    ```
!!! method
    <h2 id="status_message" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">status_message <em class="small">method</em></h2>

    returns the status message to display

???+ source "status_message <em class='small'>source</em>"
    ```python
    def status_message(self) -> str:
            "returns the status message to display"
            num_lines = self.m.console.height - 4
            last_error = "\n".join(self.last_error.split("\n")[-num_lines:])
            if self.status == "running":
                self.title = "runner running"
                self.border = "gold1"
            elif last_error == "":
                self.title = "runner succeded"
                self.border = "green"
            else:
                self.title = "runner failed"
                self.border = "red"
            self.title = f"{self.title} [blue]({round(time.time() - self.time)}s)[/]"

            return (
                f"runner is {self.status}"
                f"{round(time.time() - self.time)}\n"
                f"pid: {self.proc.pid}\n"
                f"hash: {self.m.content_dir_hash}\n"
                f"{last_error}"
            )
    ```
    ]]></content>
  </entry>
  <entry>
    <title>exceptions.py</title>

    <id>https://markata.dev/markata/exceptions/</id>
    <link href="https://markata.dev/markata/exceptions/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
None
    ]]></summary>

    <content type="html"><![CDATA[
---

None

---
    ]]></content>
  </entry>
  <entry>
    <title>plugins.py</title>

    <id>https://markata.dev/markata/cli/plugins/</id>
    <link href="https://markata.dev/markata/cli/plugins/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
None
    ]]></summary>

    <content type="html"><![CDATA[
---

None

---
    ]]></content>
  </entry>
  <entry>
    <title>summary.py</title>

    <id>https://markata.dev/markata/cli/summary/</id>
    <link href="https://markata.dev/markata/cli/summary/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
Run it Configuration There are two main things currently supported by summary, It can count the number of posts based on a filter ( grid_attr`). grid_attr…
    ]]></summary>

    <content type="html"><![CDATA[
---

## Run it

``` bash
python -m markata.cli.summary
```

## Configuration

There are two main things currently supported by summary, It can count the
number of posts based on a filter (`filter_count'), and it can automatically
list all the values of an attribute and the number of posts that have that
attribute (`grid_attr`).

### grid_attr

`grid_attr` will map over all posts, find all values for each attribute
configured, then report the number of posts for each value.

``` toml
[markata.summary]
grid_attr = ['tags', 'series']
```

Example output that will be shown in the summary, counting all posts with each
tag value.

```
TAGS
247  python
90   linux
68   cli
49   kedro
46   bash
```

### filter_counts

`filter_count` will pass a given filter into `markata.map` and return the number
of posts.

```
[[markata.summary.filter_count]]
name='drafts'
filter="published == 'False'"
color='red'

[[markata.summary.filter_count]]
name='articles'
color='dark_orange'

[[markata.summary.filter_count]]
name='py_modules'
filter='"plugin" not in slug and "docs" not in str(path)'
color="yellow1"

[markata.summary.filter_count.published]
filter="published == 'True'"
color='green1'

[markata.summary.filter_count.plugins]
filter='"plugin" in slug and "docs" not in str(path)'
color="blue"

[markata.summary.filter_count.docs]
filter="'docs' in str(path)"
color='purple'
```

Example output might look like this, showing the number of posts that contained
within each filter specified.

```
8 drafts
66 articles
20 py_modules
58 published
38 plugins
8 docs
```

---

!!! function
    <h2 id="cli" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">cli <em class="small">function</em></h2>

    Markata hook to implement base cli commands.

???+ source "cli <em class='small'>source</em>"
    ```python
    def cli(app: typer.Typer, markata: "Markata") -> None:
        """
        Markata hook to implement base cli commands.
        """
        summary_app = typer.Typer()
        app.add_typer(summary_app, name="summary")

        @summary_app.callback(invoke_without_command=True)
        def summary():
            "show the application summary"
            from rich import print

            markata.console.quiet = True

            print(Summary(markata, simple=True))
    ```
!!! method
    <h2 id="get_grid" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">get_grid <em class="small">method</em></h2>

    create a rich grid to display the summary

???+ source "get_grid <em class='small'>source</em>"
    ```python
    def get_grid(self) -> None:
            "create a rich grid to display the summary"
            self.grid = Table.grid(expand=True)

            for filter_count in self.m.config.summary.filter_count:
                self.filter_count(filter_count)

            for attr in self.m.config.summary.grid_attr:
                self.grid_attr(attr)

            return self.grid
    ```
!!! method
    <h2 id="filter_count" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">filter_count <em class="small">method</em></h2>

    add a row in the grid for the number of items in a filter config

???+ source "filter_count <em class='small'>source</em>"
    ```python
    def filter_count(
            self,
            fc: FilterCount,
        ) -> None:
            "add a row in the grid for the number of items in a filter config"
            self.grid.add_row(
                f"[{fc.color}]{len(self.m.map(filter=fc.filter))}[/] {fc.name}"
            )
    ```
!!! method
    <h2 id="grid_attr" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">grid_attr <em class="small">method</em></h2>

    add attribute the the object grid

???+ source "grid_attr <em class='small'>source</em>"
    ```python
    def grid_attr(self, attr: str) -> None:
            "add attribute the the object grid"
            posts = list(
                flatten(
                    [
                        tags if isinstance(tags, list) else [tags]
                        for a in self.m.posts
                        if (tags := a.get(attr, None)) is not None
                    ],
                ),
            )
            if len(posts) > 0:
                self.grid.add_row()
                self.grid.add_row(f"[bold gold1]{attr.upper()}[/]")
                for post, count in Counter(posts).most_common():
                    self.grid.add_row(f"{count} {' ' * (3 - len(str(count)))} {post}")
    ```
!!! function
    <h2 id="summary" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">summary <em class="small">function</em></h2>

    show the application summary

???+ source "summary <em class='small'>source</em>"
    ```python
    def summary():
            "show the application summary"
            from rich import print

            markata.console.quiet = True

            print(Summary(markata, simple=True))
    ```
    ]]></content>
  </entry>
  <entry>
    <title>seo.py</title>

    <id>https://markata.dev/markata/plugins/seo/</id>
    <link href="https://markata.dev/markata/plugins/seo/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
manifest plugin
    ]]></summary>

    <content type="html"><![CDATA[
---

manifest plugin

---
    ]]></content>
  </entry>
  <entry>
    <title>tui.py</title>

    <id>https://markata.dev/markata/plugins/tui/</id>
    <link href="https://markata.dev/markata/plugins/tui/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
None
    ]]></summary>

    <content type="html"><![CDATA[
---

None

---
    ]]></content>
  </entry>
  <entry>
    <title>rss.py</title>

    <id>https://markata.dev/markata/plugins/rss/</id>
    <link href="https://markata.dev/markata/plugins/rss/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
[DEPRECATED] The plugin is deprecated and will be removed in a future version. Please use instead, which provides more comprehensive feed generation…
    ]]></summary>

    <content type="html"><![CDATA[
---

[DEPRECATED] The `markata.plugins.rss` plugin is deprecated and will be removed in a
future version. Please use `markata.plugins.feeds` instead, which provides more
comprehensive feed generation capabilities.

## Installation

This plugin is deprecated. Use `markata.plugins.feeds` instead:

```toml
hooks = [
    "markata.plugins.feeds",  # Use this instead
    # "markata.plugins.rss",  # Deprecated
]
```

# Migration Guide

To migrate to the new feeds plugin:

1. Remove rss plugin from hooks:
```toml
# Remove or comment out
# "markata.plugins.rss"
```

2. Add feeds plugin:
```toml
hooks = [
    "markata.plugins.feeds"
]
```

3. Update configuration:
```toml
[markata.feeds]
# RSS feed configuration
rss = { output = "rss.xml" }

# Optional: Add other feed formats
atom = { output = "atom.xml" }
json = { output = "feed.json" }
```

See the feeds plugin documentation for more configuration options.

# Legacy Configuration

If you must continue using this plugin temporarily, configure in `markata.toml`:

```toml
[markata]
url = "https://example.com"
title = "Site Title"
author_name = "Author Name"
author_email = "author@example.com"
icon = "favicon.ico"
lang = "en"
```

# Dependencies

This plugin depends on:
- feedgen for RSS generation
- pytz for timezone handling

WARNING: This plugin is deprecated and will be removed in a future version.
Please migrate to `markata.plugins.feeds` as soon as possible.

---
    ]]></content>
  </entry>
  <entry>
    <title>load.py</title>

    <id>https://markata.dev/markata/plugins/load/</id>
    <link href="https://markata.dev/markata/plugins/load/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin is responsible for loading and parsing markdown files with frontmatter into Post objects. It provides parallel loading capabilities and handles…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.load` plugin is responsible for loading and parsing markdown files
with frontmatter into Post objects. It provides parallel loading capabilities and
handles both modern Pydantic-based and legacy frontmatter validation.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.load",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.load",
]
```

Note: Disabling this plugin will prevent Markata from loading any markdown files.
This will effectively disable most of Markata's functionality.

## Configuration

Configure loading behavior in your `markata.toml`:

```toml
[markata]
# Directories containing markdown content
content_directories = [
    "content",
    "posts"
]

# Optional: Set to true to use legacy frontmatter validation
legacy_frontmatter = false

# Optional: Number of worker processes for parallel loading
load_workers = 4
```

## Functionality

## File Loading

The plugin:
1. Discovers markdown files in content directories
2. Loads file content and frontmatter
3. Validates frontmatter against Post model
4. Creates Post objects for further processing

## Parallel Processing

Loading is parallelized using:
- Process pool for file reading
- Configurable number of workers
- Chunked file processing

## Validation Modes

Supports two validation approaches:
1. Modern Pydantic-based validation (default)
   - Strict type checking
   - Automatic type coercion
   - Detailed validation errors

2. Legacy frontmatter validation
   - Looser type checking
   - Compatible with older content
   - Less strict validation

## Error Handling

The plugin provides:
- Detailed validation error messages
- Per-file error reporting
- Graceful fallback to legacy mode
- Optional strict validation

## Registered Attributes

The plugin adds:
- `articles`: List of loaded Post objects
- `content_directories`: List of content source directories

## Dependencies

This plugin depends on:
- python-frontmatter for YAML parsing
- pydantic for validation
- multiprocessing for parallel loading

---

!!! function
    <h2 id="load_file_content" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">load_file_content <em class="small">function</em></h2>

    Load file content without validation.

???+ source "load_file_content <em class='small'>source</em>"
    ```python
    def load_file_content(path: Path) -> tuple[Path, dict]:
        """Load file content without validation."""
        try:
            with open(path, "r") as f:
                raw_content = f.read()
            try:
                content = frontmatter.loads(raw_content)
            except Exception:
                content = None
            content["raw"] = raw_content
            return path, content
        except Exception:
            return path, None
    ```
    ]]></content>
  </entry>
  <entry>
    <title>glob.py</title>

    <id>https://markata.dev/markata/plugins/glob/</id>
    <link href="https://markata.dev/markata/plugins/glob/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin handles file discovery using glob patterns. It determines which files should be processed by Markata based on configured patterns. A glob is a…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.glob` plugin handles file discovery using glob patterns.
It determines which files should be processed by Markata based on configured patterns.

> A glob is a string that can be used to match files and directories.
> https://docs.python.org/3/library/pathlib.html#pathlib.Path.glob

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.glob",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.glob",
]
```

## Configuration

Configure glob patterns and behavior in your `markata.toml`:

```toml
[markata.glob]
# Single pattern
glob_patterns = "**/*.md"

# Or multiple patterns
glob_patterns = [
    "content/**/*.md",
    "pages/**/*.md",
    "posts/**/*.md"
]

# Control .gitignore integration
use_gitignore = true  # Set to false to process gitignored files
```

## Configuration Options

- `glob_patterns`: String or list of strings specifying which files to process
  - Default: `["**/*.md"]` (all markdown files in any subdirectory)
  - Supports any valid glob pattern
- `use_gitignore`: Boolean controlling whether to respect .gitignore rules
  - Default: `true`
  - When true, files matching .gitignore patterns are skipped

## Functionality

The glob plugin runs early in the Markata pipeline to discover files for processing.
It supports:
- Single or multiple glob patterns
- .gitignore integration
- Recursive directory searching
- Common glob patterns (*, **, ?, [...])

## Dependencies

This plugin has no dependencies on other Markata plugins.

---
    ]]></content>
  </entry>
  <entry>
    <title>docs.py</title>

    <id>https://markata.dev/markata/plugins/docs/</id>
    <link href="https://markata.dev/markata/plugins/docs/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin automatically generates documentation pages from Python source code docstrings. It parses Python files, extracts docstrings and code structure, and…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.docs` plugin automatically generates documentation pages from Python
source code docstrings. It parses Python files, extracts docstrings and code structure,
and creates markdown documentation.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.docs",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.docs",
]
```

## Configuration

Configure documentation generation in your `markata.toml`:

```toml
[markata.docs]
# Directories containing Python files to document
content_directories = [
    "markata",
    "tests"
]

# Template for generated documentation
template = "docs/template.md.j2"
```

## Template Variables

The following variables are available in documentation templates:
- `module`: Module name
- `docstring`: Module docstring
- `classes`: List of class definitions and their docstrings
- `functions`: List of function definitions and their docstrings
- `source`: Path to source file
- `ast`: Abstract Syntax Tree of the module

## Functionality

## Documentation Generation

The plugin:
1. Finds Python files in configured directories
2. Parses files using Python's AST
3. Extracts docstrings and code structure
4. Applies templates to generate markdown
5. Creates documentation pages in the output directory

## AST Analysis

The plugin analyzes:
- Module-level docstrings
- Class definitions and docstrings
- Function definitions and docstrings
- Function parameters and return types
- Code structure and relationships

## Registered Attributes

The plugin adds these attributes to Markata:
- `py_files`: List of Python files being documented
- `content_directories`: List of directories being processed

## Dependencies

This plugin depends on:
- ast (Python standard library) for code parsing
- jinja2 for template rendering

---

!!! function
    <h2 id="glob" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">glob <em class="small">function</em></h2>

    finds k

    ## Parameters

    `markata` the markata object

???+ source "glob <em class='small'>source</em>"
    ```python
    def glob(markata: "MarkataDocs") -> None:
        """
        finds k

        ## Parameters

        `markata` the markata object

        """

        import glob

        markata.py_files = [Path(f) for f in glob.glob("**/*.py", recursive=True)]

        content_directories = list({f.parent for f in markata.py_files})
        if "content_directories" in markata.__dict__:
            markata.content_directories.extend(content_directories)
        else:
            markata.content_directories = content_directories

        try:
            ignore = True
        except KeyError:
            ignore = True

        if ignore and (Path(".gitignore").exists() or Path(".markataignore").exists()):
            import pathspec

            lines = []

            if Path(".gitignore").exists():
                lines.extend(Path(".gitignore").read_text().splitlines())

            if Path(".markataignore").exists():
                lines.extend(Path(".markataignore").read_text().splitlines())

        spec = pathspec.PathSpec.from_lines("gitwildmatch", lines)

        markata.py_files = [
            file for file in markata.py_files if not spec.match_file(str(file))
        ]
    ```
!!! function
    <h2 id="load" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">load <em class="small">function</em></h2>

    similar to [glob](../glob)

???+ source "load <em class='small'>source</em>"
    ```python
    def load(markata: "MarkataDocs") -> None:
        """
        similar to [glob](../glob)
        """
        # if "articles" not in markata.__dict__:
        #     markata.articles = []
        for py_file in markata.py_files:
            with markata.cache as cache:
                markata.articles.append(make_article(markata, py_file, cache))
    ```
    ]]></content>
  </entry>
  <entry>
    <title>__init__.py</title>

    <id>https://markata.dev/markata/plugins/init/</id>
    <link href="https://markata.dev/markata/plugins/init/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
None
    ]]></summary>

    <content type="html"><![CDATA[
---

None

---
    ]]></content>
  </entry>
  <entry>
    <title>skip.py</title>

    <id>https://markata.dev/markata/plugins/skip/</id>
    <link href="https://markata.dev/markata/plugins/skip/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
Post Skipping and Caching Plugin
    ]]></summary>

    <content type="html"><![CDATA[
---

Post Skipping and Caching Plugin

---

!!! function
    <h2 id="post_model" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">post_model <em class="small">function</em></h2>

    Add skip attribute to post models.

???+ source "post_model <em class='small'>source</em>"
    ```python
    def post_model(markata: "Markata") -> None:
        """Add skip attribute to post models."""
        markata.post_models.append(PostModel)
    ```
!!! function
    <h2 id="load" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">load <em class="small">function</em></h2>

    Runs after posts are loaded to check if they should be skipped.

???+ source "load <em class='small'>source</em>"
    ```python
    def load(markata: "Markata") -> None:
        """Runs after posts are loaded to check if they should be skipped."""
        raw_should_skip = os.environ.get("MARKATA_SKIP", "true")
        should_skip = raw_should_skip.lower() in ["true", "1", "t", "y", "yes", "on"]
        if not should_skip:
            return
        for post in markata.posts:
            if hasattr(post, "raw"):
                key = markata.make_hash("skip", post.raw)
                if markata.cache.get(key) == "done" and not post.get("jinja", False):
                    post.skip = True
        markata.console.log(
            f"{len(markata.filter('skip'))}/{len(markata.posts)} posts skipped"
        )
        markata.console.log(
            f"{len(markata.filter('not skip'))}/{len(markata.posts)} posts not skipped"
        )
    ```
!!! function
    <h2 id="save" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">save <em class="small">function</em></h2>

    Save the 'done' status for processed posts.

???+ source "save <em class='small'>source</em>"
    ```python
    def save(markata: "Markata") -> None:
        """Save the 'done' status for processed posts."""
        # for post in markata.posts:
        raw_should_skip = os.environ.get("MARKATA_SKIP", "true")
        should_skip = raw_should_skip.lower() in ["true", "1", "t", "y", "yes", "on"]
        if not should_skip:
            return
        for post in markata.filter("not skip"):
            if hasattr(post, "raw"):
                if post.output_html.exists():
                    key = markata.make_hash("skip", post.raw)
                    markata.cache.set(key, "done")
    ```
    ]]></content>
  </entry>
  <entry>
    <title>feeds.py</title>

    <id>https://markata.dev/markata/plugins/feeds/</id>
    <link href="https://markata.dev/markata/plugins/feeds/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin is used to create feed pages, which are lists of posts. The list is generated using a , then each post in the list is rendered with a before being…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.feeds` plugin is used to create feed pages, which are lists of
posts.  The list is generated using a `filter`, then each post in the list is
rendered with a `card_template` before being applied to the `body` of the
`template`.

## Installation

This plugin is built-in and enabled by default, but in you want to be very
explicit you can add it to your list of existing plugins.

``` toml
hooks = [
   "markata.plugins.feeds",
   ]
```

## Configuration

# set default template and card_template

At the root of the markata.feeds config you may set `template`, and
`card_template`.  These will become your defaults for every feed you create.
If you do not set these, markata will use it's defaults.  The defaults are
designed to work for a variety of use cases, but are not likely the best for
all.

``` toml
[markata.feeds_config]
template="pages/templates/archive_template.html"
card_template="plugins/feed_card_template.html"
```

# pages

Underneath of the `markata.feeds` we will create a new map for each page where
the name of the map will be the name of the page.


The following config will create a page at `/all-posts` that inclues every
single post.

``` toml
[[markata.feeds]]
title="All Posts"
slug='all'
filter="True"
```

# template

The `template` configuration key is a file path to the template that you want
to use to create the feed.  You may set the default template you want to use
for all feeds under `[markata.feeds]`, as well as override it inside of each
feeds config.

The template is a jinja style template that expects to fill in a `title` and
`body` variable.

``` html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>{{ title }}</title>
  </head>
  <body>
    <ul>
        {{ body }}
    </ul>
  </body>
</html>
```

!!! note
    I highly reccomend putting your `body` in a `<ul>`, and wrapping your
    `card_template`s in an `<li>`.

# card_template

All keys available from each post is available to put into your jinja
template.  These can either be placed there in your post frontmatter, or
through a plugin that automatically adds to the post before the save phase.

Here is a very simple example that would give a link to each post with the
title and date.

``` toml
[[markata.feeds]]
slug='all'
title='All Posts'
filter="True"
card_template='''
<li>
    <a href={{markata.config.get('path_prefix', '')}}{{slug}}>
        {{title}}-{{date}}
    </a>
</li>
'''
```

# filter

The filter is a python expression ran on every post that expects to return a
boolean.  The variables available to this expression are every key in your
frontmatter, plus the `timedelta` function, and `parse` function to more easily
work with dates.

# Feed Examples

True can be passed in to make a feed of all the posts you have.

``` toml
[[markata.feeds]]
slug='all'
title='All Posts'
filter="True"
```

You can compare against the values of the keys from your frontmatter.  This
example creates a feed that includes every post where published is `True`.

``` toml
[[markata.feeds]]
slug='draft'
title='Draft'
filter="published=='False'"
```

We can also compare against dates.  The
[markata.plugins.datetime](https://markata.dev/markata/plugins/datetime/)
plugin, automatically adds `today` as today's date and `now` as the current
datetime.  These are quite handy to create feeds for scheduled, recent, or
today's posts.  The following two examples will create a feed for scheduled
posts and for today's posts respectively.

``` toml
[[markata.feeds]]
slug='scheduled'
title='Scheduled'
filter="date>today"

[[markata.feeds]]
slug='today'
title='Today'
filter="date==today"
```

If you have list of items in your frontmatter for something like `tags`, you
can check for the existence of a tag in the list.

``` toml
[[markata.feeds]]
slug='python'
title='Python'
filter="date<=today and 'python' in tags"
```

And of course you can combine all the things into larger expressions.  Here is
one example of the main feed on my blog.

``` toml
[[markata.feeds]]
slug='blog'
title='Blog'
filter="date<=today and templateKey in ['blog-post'] and published =='True'"
```

Here is another example that shows my drafts for a particular tag.

``` toml
[[markata.feeds]]
slug='python-draft'
title='Python Draft'
filter="date<=today and 'python' in tags and published=='False'"
```

# Defaults

By default feeds will create one feed page at `/archive/` that includes all
posts.

``` toml
[[markata.feeds]]
slug='archive'
title='All Posts'
filter="True"
```

---

!!! class
    <h2 id="Feed" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">Feed <em class="small">class</em></h2>

    A storage class for markata feed objects.

    ## Usage

    ``` python
    from markata import Markata
    m = Markata()

    # access posts for a feed
    m.feeds.docs.posts

    # access config for a feed
    m.feeds.docs.config
    ```

???+ source "Feed <em class='small'>source</em>"
    ```python
    class Feed(pydantic.BaseModel, JupyterMixin):
        """A storage class for markata feed objects.

        ## Usage

        ``` python
        from markata import Markata
        m = Markata()

        # access posts for a feed
        m.feeds.docs.posts

        # access config for a feed
        m.feeds.docs.config
        ```
        """

        config: FeedConfig
        markata: Markata = pydantic.Field(exclude=True)

        model_config = ConfigDict(
            validate_assignment=False,
            arbitrary_types_allowed=True,
            extra="allow",
            str_strip_whitespace=True,
            validate_default=True,
            coerce_numbers_to_str=True,
            populate_by_name=True,
        )

        @property
        def name(self) -> str:
            """The name of the feed, used for accessing it in the feeds object."""
            return self.config.name

        @property
        def posts(self):
            posts = self.map("post")
            if self.config.head is not None and self.config.tail is not None:
                head_posts = posts[: self.config.head]
                tail_posts = posts[-self.config.tail :]
                return PrettyList(head_posts + tail_posts)
            if self.config.head is not None:
                return PrettyList(posts[: self.config.head])
            if self.config.tail is not None:
                return PrettyList(posts[-self.config.tail :])
            return PrettyList(posts)

        def first(
            self: "Markata",
        ) -> list:
            return self.posts[0]

        def last(
            self: "Markata",
        ) -> list:
            return self.posts[-1]

        def map(self, func="post", **args):
            return self.markata.map(func, **{**self.config.dict(), **args})

        @property
        def __rich_console__(self) -> "Console":
            return self.markata.console

        def __rich__(self) -> Table:
            table = Table(title=f"Feed: {self.name}")

            table.add_column("Post", justify="right", style="cyan", no_wrap=True)
            table.add_column("slug", justify="left", style="green")
            table.add_column("published", justify="left", style="green")

            for post in self.posts:
                table.add_row(post.title, post.slug, str(post.published))

            return table
    ```
!!! class
    <h2 id="MarkataTemplateCache" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">MarkataTemplateCache <em class="small">class</em></h2>

    Template bytecode cache for improved performance.

???+ source "MarkataTemplateCache <em class='small'>source</em>"
    ```python
    class MarkataTemplateCache(jinja2.BytecodeCache):
        """Template bytecode cache for improved performance."""

        def __init__(self, directory):
            self.directory = Path(directory)
            self.directory.mkdir(parents=True, exist_ok=True)

        def load_bytecode(self, bucket):
            filename = self.directory / f"{bucket.key}.cache"
            if filename.exists():
                with open(filename, "rb") as f:
                    bucket.bytecode_from_string(f.read())

        def dump_bytecode(self, bucket):
            filename = self.directory / f"{bucket.key}.cache"
            with open(filename, "wb") as f:
                f.write(bucket.bytecode_to_string())
    ```
!!! function
    <h2 id="pre_render" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">pre_render <em class="small">function</em></h2>

    Create the Feeds object and attach it to markata.

???+ source "pre_render <em class='small'>source</em>"
    ```python
    def pre_render(markata: Markata) -> None:
        """
        Create the Feeds object and attach it to markata.
        """
        markata.feeds = Feeds(markata)
    ```
!!! function
    <h2 id="save" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">save <em class="small">function</em></h2>

    Creates a new feed page for each page in the config.

???+ source "save <em class='small'>source</em>"
    ```python
    def save(markata: Markata) -> None:
        """
        Creates a new feed page for each page in the config.
        """
        with markata.cache as cache:
            for feed in markata.feeds.values():
                create_page(
                    markata,
                    feed,
                    cache,
                )

        home = Path(str(markata.config.output_dir)) / "index.html"
        archive = Path(str(markata.config.output_dir)) / "archive" / "index.html"
        if not home.exists() and archive.exists():
            shutil.copy(str(archive), str(home))

        xsl_template = get_template(markata.jinja_env, feed.config.xsl_template)
        xsl = xsl_template.render(
            markata=markata,
            __version__=__version__,
            today=datetime.datetime.today(),
            config=markata.config,
        )
        xsl_file = Path(markata.config.output_dir) / "rss.xsl"
        # Only read file if it exists and we need to compare
        should_write = True
        if xsl_file.exists():
            current_xsl = xsl_file.read_text()
            should_write = current_xsl != xsl

        if should_write:
            xsl_file.write_text(xsl)
    ```
!!! function
    <h2 id="create_page" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">create_page <em class="small">function</em></h2>

    create an html unorderd list of posts.

???+ source "create_page <em class='small'>source</em>"
    ```python
    def create_page(
        markata: Markata,
        feed: Feed,
        cache,
    ) -> None:
        """
        create an html unorderd list of posts.
        """

        template = get_template(markata.jinja_env, feed.config.template)
        partial_template = get_template(markata.jinja_env, feed.config.partial_template)
        canonical_url = f"{markata.config.url}/{feed.config.slug}/"

        # Get templates mtime to bust cache when any template changes
        templates_mtime = get_templates_mtime(markata.jinja_env)

        # Use simpler hash for posts instead of expensive str(post.to_dict())
        # Hash just the essential post identifiers: slug + content_hash
        cache_key_posts = f"feed_hash_posts_{feed.config.slug}"
        if not hasattr(markata, "_feed_hash_cache"):
            markata._feed_hash_cache = {}

        if cache_key_posts not in markata._feed_hash_cache:
            # Use post slugs and published dates instead of full to_dict()
            # This provides a stable, lightweight cache key
            posts_data = feed.map("(post.slug, str(getattr(post, 'date', '')), getattr(post, 'title', ''))")
            markata._feed_hash_cache[cache_key_posts] = str(sorted(posts_data))

        posts_hash_data = markata._feed_hash_cache[cache_key_posts]

        key = markata.make_hash(
            "feeds",
            template,
            __version__,
            markata.config.url,
            markata.config.description,
            feed.config.title,
            posts_hash_data,  # Use cached post data
            canonical_url,
            str(templates_mtime),  # Track template file changes
            # datetime.datetime.today(),
            # markata.config,
        )

        html_key = markata.make_hash(key, "html")
        html_partial_key = markata.make_hash(key, "partial_html")
        feed_rss_key = markata.make_hash(key, "rss")
        feed_sitemap_key = markata.make_hash(key, "sitemap")
        feed_atom_key = markata.make_hash(key, "atom")

        feed_html_from_cache = markata.precache.get(html_key)
        feed_html_partial_from_cache = markata.precache.get(html_partial_key)
        feed_rss_from_cache = markata.precache.get(feed_rss_key)
        feed_sitemap_from_cache = markata.precache.get(feed_sitemap_key)
        feed_atom_from_cache = markata.precache.get(feed_atom_key)

        output_file = Path(markata.config.output_dir) / feed.config.slug / "index.html"
        partial_output_file = (
            Path(markata.config.output_dir) / feed.config.slug / "partial" / "index.html"
        )
        rss_output_file = Path(markata.config.output_dir) / feed.config.slug / "rss.xml"
        sitemap_output_file = (
            Path(markata.config.output_dir) / feed.config.slug / "sitemap.xml"
        )
        atom_output_file = (
            Path(markata.config.output_dir) / feed.config.slug / "atom.xml"
        )

        # Create all directories in one batch
        partial_output_file.parent.mkdir(exist_ok=True, parents=True)

        from_cache = True

        # ---------- HTML ----------
        if feed_html_from_cache is None:
            from_cache = False
            feed_html = template.render(
                markata=markata,
                __version__=__version__,
                post=feed.config.model_dump(),
                url=markata.config.url,
                config=markata.config,
                feed=feed,
            )
            cache.set(html_key, feed_html)
        else:
            feed_html = feed_html_from_cache

        # ---------- Partial HTML ----------
        if feed_html_partial_from_cache is None:
            from_cache = False
            feed_html_partial = partial_template.render(
                markata=markata,
                __version__=__version__,
                post=feed.config.model_dump(),
                url=markata.config.url,
                config=markata.config,
                feed=feed,
            )
            cache.set(html_partial_key, feed_html_partial)
        else:
            feed_html_partial = feed_html_partial_from_cache

        # ---------- RSS ----------
        if feed.config.rss:
            if feed_rss_from_cache is None:
                from_cache = False
                rss_template = get_template(markata.jinja_env, feed.config.rss_template)
                feed_rss = rss_template.render(markata=markata, feed=feed)
                cache.set(feed_rss_key, feed_rss)
            else:
                feed_rss = feed_rss_from_cache
        else:
            feed_rss = None

        # ---------- Sitemap ----------
        if feed.config.sitemap:
            if feed_sitemap_from_cache is None:
                from_cache = False
                sitemap_template = get_template(markata.jinja_env, feed.config.sitemap_template)
                feed_sitemap = sitemap_template.render(markata=markata, feed=feed)
                cache.set(feed_sitemap_key, feed_sitemap)
            else:
                feed_sitemap = feed_sitemap_from_cache
        else:
            feed_sitemap = None

        # ---------- Atom ----------
        if feed.config.atom:
            if feed_atom_from_cache is None:
                from_cache = False
                atom_template = get_template(markata.jinja_env, feed.config.atom_template)
                feed_atom = atom_template.render(
                    markata=markata,
                    feed=feed,
                    datetime=datetime,  # ⭐ so the template can use datetime
                )
                cache.set(feed_atom_key, feed_atom)
            else:
                feed_atom = feed_atom_from_cache
            # If everything came from cache and files exist, bail early
            if (
                from_cache
                and output_file.exists()
                and partial_output_file.exists()
                and (not feed.config.rss or rss_output_file.exists())
                and (not feed.config.sitemap or sitemap_output_file.exists())
                and (not feed.config.atom or atom_output_file.exists())
            ):
                return

        # Write HTML
        current_html = output_file.read_text() if output_file.exists() else ""
        if current_html != feed_html:
            output_file.write_text(feed_html)

        # Write partial HTML
        current_partial_html = (
            partial_output_file.read_text() if partial_output_file.exists() else ""
        )
        if current_partial_html != feed_html_partial:
            partial_output_file.write_text(feed_html_partial)

        # Write RSS (if enabled)
        if feed_rss is not None:
            current_rss = rss_output_file.read_text() if rss_output_file.exists() else ""
            if current_rss != feed_rss:
                rss_output_file.write_text(feed_rss)

        # Write sitemap (if enabled)
        if feed_sitemap is not None:
            current_sitemap = (
                sitemap_output_file.read_text() if sitemap_output_file.exists() else ""
            )
            if current_sitemap != feed_sitemap:
                sitemap_output_file.write_text(feed_sitemap)

        # Write Atom (if enabled)
        if feed_atom is not None:
            current_atom = atom_output_file.read_text() if atom_output_file.exists() else ""
            if current_atom != feed_atom:
                atom_output_file.write_text(feed_atom)
    ```
!!! function
    <h2 id="create_card" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">create_card <em class="small">function</em></h2>

    Creates a card for one post based on the configured template.  If no
    template is configured it will create one with the post title and dates
    (if present).

???+ source "create_card <em class='small'>source</em>"
    ```python
    def create_card(
        markata: "Markata",
        post: "Post",
        template: Optional[str] = None,
        cache=None,
    ) -> Any:
        """
        Creates a card for one post based on the configured template.  If no
        template is configured it will create one with the post title and dates
        (if present).
        """
        if template is None:
            template = markata.config.get("feeds_config", {}).get("card_template", None)

        # Get templates mtime to bust cache when any template changes
        templates_mtime = get_templates_mtime(markata.jinja_env)

        key = markata.make_hash(
            "feeds", template, str(post.to_dict()), str(templates_mtime)
        )

        card = markata.precache.get(key)
        if card is not None:
            return card

        if template is None:
            if "date" in post:
                card = textwrap.dedent(
                    f"""
                    <li class='post'>
                    <a href="/{markata.config.path_prefix}{post.slug}/">
                        {post.title}
                        {post.date.year}-
                        {post.date.month}-
                        {post.date.day}
                    </a>
                    </li>
                    """,
                )
            else:
                card = textwrap.dedent(
                    f"""
                    <li class='post'>
                    <a href="/{markata.config.path_prefix}{post.slug}/">
                        {post.title}
                    </a>
                    </li>
                    """,
                )
        else:
            try:
                _template = Template(Path(template).read_text())
            except FileNotFoundError:
                _template = Template(template)
            except OSError:  # thrown by File name too long
                _template = Template(template)
            card = _template.render(post=post, **post.to_dict())
        cache.add(key, card)
        return card
    ```
!!! class
    <h2 id="Feeds" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">Feeds <em class="small">class</em></h2>

    A storage class for all markata Feed objects

    ``` python
    from markata import Markata
    markata = Markata()

    markata.feeds

    # access all config
    markata.feeds.config

    # refresh list of posts in all feeds
    markata.feeds.refresh()

    # iterating over feeds gives the name of the feed
    for k in markata.feeds:
         print(k)

    # project-gallery
    # docs
    # autodoc
    # core_modules
    # plugins
    # archive

    # iterate over items like keys and values in a dict, items returns name of
    # feed and a feed object
    for k, v in markata.feeds.items():
        print(k, len(v.posts))

    # project-gallery 2
    # docs 6
    # autodoc 65
    # core_modules 26
    # plugins 39
    # archive 65

    # values can be iterated over in just the same way
    for v in markata.feeds.values():
         print(len(v.posts))
    # 2
    # 6
    # 65
    # 26
    # 39
    # 65

???+ source "Feeds <em class='small'>source</em>"
    ```python
    class Feeds(JupyterMixin):
        """A storage class for all markata Feed objects

        ``` python
        from markata import Markata
        markata = Markata()

        markata.feeds

        # access all config
        markata.feeds.config

        # refresh list of posts in all feeds
        markata.feeds.refresh()

        # iterating over feeds gives the name of the feed
        for k in markata.feeds:
             print(k)

        # project-gallery
        # docs
        # autodoc
        # core_modules
        # plugins
        # archive

        # iterate over items like keys and values in a dict, items returns name of
        # feed and a feed object
        for k, v in markata.feeds.items():
            print(k, len(v.posts))

        # project-gallery 2
        # docs 6
        # autodoc 65
        # core_modules 26
        # plugins 39
        # archive 65

        # values can be iterated over in just the same way
        for v in markata.feeds.values():
             print(len(v.posts))
        # 2
        # 6
        # 65
        # 26
        # 39
        # 65
        """

        def __init__(self, markata: Markata) -> None:
            self.markata = markata
            self.config = {f.name: f for f in markata.config.feeds}
            self.refresh()

        def refresh(self):
            """Refresh all of the feeds objects"""
            for feed_config in self.markata.config.feeds:
                # Ensure feed has a name, falling back to slug if needed
                if feed_config.name is None and feed_config.slug is not None:
                    feed_config.name = feed_config.slug.replace("-", "_")
                elif feed_config.name is None and feed_config.slug is None:
                    feed_config.slug = "archive"
                    feed_config.name = "archive"

                feed = Feed(config=feed_config, markata=self.markata)
                self.__setattr__(feed.name, feed)

        def __iter__(self):
            return iter(self.config.keys())

        def keys(self):
            return iter(self.config.keys())

        def values(self):
            return [self[feed] for feed in self.config.keys()]

        def items(self):
            return [(key, self[key]) for key in self.config]

        def __getitem__(self, key: str) -> Any:
            return getattr(self, key.replace("-", "_").lower())

        def get(self, key: str, default: Any = None) -> Any:
            return getattr(self, key.replace("-", "_").lower(), default)

        def _dict_panel(self, config) -> str:
            """pretty print configs with rich"""
            msg = ""
            for key, value in config.items():
                if isinstance(value, str):
                    if len(value) > 50:
                        value = value[:50] + "..."
                    value = value
                msg = msg + f"[grey46]{key}[/][magenta3]:[/] [grey66]{value}[/]\n"
            return msg

        def __rich__(self) -> Table:
            table = Table(title=f"Feeds {len(self.config)}")

            table.add_column("Feed", justify="right", style="cyan", no_wrap=True)
            table.add_column("posts", justify="left", style="green")
            table.add_column("config", style="magenta")

            for name in self.config:
                table.add_row(
                    name,
                    str(len(self[name].posts)),
                    self._dict_panel(self.config[name].dict()),
                )
            return table
    ```
!!! method
    <h2 id="name" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">name <em class="small">method</em></h2>

    The name of the feed, used for accessing it in the feeds object.

???+ source "name <em class='small'>source</em>"
    ```python
    def name(self) -> str:
            """The name of the feed, used for accessing it in the feeds object."""
            return self.config.name
    ```
!!! function
    <h2 id="feeds" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">feeds <em class="small">function</em></h2>

    feeds cli

???+ source "feeds <em class='small'>source</em>"
    ```python
    def feeds():
            "feeds cli"
    ```
!!! method
    <h2 id="refresh" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">refresh <em class="small">method</em></h2>

    Refresh all of the feeds objects

???+ source "refresh <em class='small'>source</em>"
    ```python
    def refresh(self):
            """Refresh all of the feeds objects"""
            for feed_config in self.markata.config.feeds:
                # Ensure feed has a name, falling back to slug if needed
                if feed_config.name is None and feed_config.slug is not None:
                    feed_config.name = feed_config.slug.replace("-", "_")
                elif feed_config.name is None and feed_config.slug is None:
                    feed_config.slug = "archive"
                    feed_config.name = "archive"

                feed = Feed(config=feed_config, markata=self.markata)
                self.__setattr__(feed.name, feed)
    ```
!!! method
    <h2 id="_dict_panel" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">_dict_panel <em class="small">method</em></h2>

    pretty print configs with rich

???+ source "_dict_panel <em class='small'>source</em>"
    ```python
    def _dict_panel(self, config) -> str:
            """pretty print configs with rich"""
            msg = ""
            for key, value in config.items():
                if isinstance(value, str):
                    if len(value) > 50:
                        value = value[:50] + "..."
                    value = value
                msg = msg + f"[grey46]{key}[/][magenta3]:[/] [grey66]{value}[/]\n"
            return msg
    ```
    ]]></content>
  </entry>
  <entry>
    <title>didyoumean.py</title>

    <id>https://markata.dev/markata/cli/didyoumean/</id>
    <link href="https://markata.dev/markata/cli/didyoumean/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
dummy didyoumean page for testing didyoumean suggestions
    ]]></summary>

    <content type="html"><![CDATA[
---

dummy didyoumean page for testing didyoumean suggestions

---
    ]]></content>
  </entry>
  <entry>
    <title>covers.py</title>

    <id>https://markata.dev/markata/plugins/covers/</id>
    <link href="https://markata.dev/markata/plugins/covers/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin generates custom cover images for your posts using configurable templates. It supports multiple cover image formats with different sizes, fonts,…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.covers` plugin generates custom cover images for your posts using
configurable templates. It supports multiple cover image formats with different sizes,
fonts, and layouts for various platforms (e.g., blog, social media, dev.to).

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.covers",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.covers",
]
```

## Configuration

Configure multiple cover image templates in your `markata.toml`:

```toml
[[markata.covers]]
name = '-dev'                                    # Suffix for generated files
template = "static/cover-template.png"           # Base template image
font = "./static/JosefinSans-Regular.ttf"        # Title font
text_font = "./static/JosefinSans-Regular.ttf"   # Description font
font_color = "rgb(185,155,165)"                 # Title color
text_font_color = "rgb(255,255,255)"            # Description color
text_key = 'description'                        # Post attribute to use for description
padding = [0, 40, 100, 300]                     # Title padding [top, right, bottom, left]
text_padding = [0, 0]                           # Description padding

[[markata.covers]]
name = ''                                       # No suffix (default cover)
template = "static/og-template.png"             # Different template for social media
font = "./static/JosefinSans-Regular.ttf"
font_color = "rgb(255,255,255)"
text_font = "./static/JosefinSans-Regular.ttf"
text_font_color = "rgb(200,200,200)"
text_key = 'description'
padding = [10, 10, 100, 300]
text_padding = [0, 0]
```

### Configuration Options

Each cover configuration supports:
- `name`: Suffix for generated files (e.g., '-dev' creates 'post-dev.png')
- `template`: Path to template image
- `font`: Path to title font file
- `text_font`: Path to description font file
- `font_color`: RGB color for title
- `text_font_color`: RGB color for description
- `text_key`: Post attribute to use for description text
- `padding`: List of 1-4 integers for title padding
- `text_padding`: List of 1-4 integers for description padding

## Functionality

## Cover Generation

The plugin:
1. Loads the template image for each configuration
2. Draws the post title using specified font and color
3. Optionally draws description text
4. Applies configured padding
5. Saves the generated cover with appropriate suffix

## File Naming

Generated files follow this pattern:
- Main cover: `<slug>.png`
- Named covers: `<slug><name>.png`

Example:
- `my-post.png` (default cover)
- `my-post-dev.png` (dev.to cover)

## Dependencies

This plugin depends on:
- Pillow (PIL) for image manipulation

---

!!! function
    <h2 id="_lazy_import_pil" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">_lazy_import_pil <em class="small">function</em></h2>

    Lazy import PIL modules when needed.

???+ source "_lazy_import_pil <em class='small'>source</em>"
    ```python
    def _lazy_import_pil():
        """Lazy import PIL modules when needed."""
        global Image, ImageDraw, ImageFont
        if Image is None:
            from PIL import Image
            from PIL import ImageDraw
            from PIL import ImageFont
    ```
!!! function
    <h2 id="resolve_padding" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">resolve_padding <em class="small">function</em></h2>

    Convert padding to a len 4 tuple

???+ source "resolve_padding <em class='small'>source</em>"
    ```python
    def resolve_padding(padding: Tuple[int, ...], markata: "Markata") -> Tuple[int, ...]:
        """Convert padding to a len 4 tuple"""
        if len(padding) == 4:
            return padding
        if len(padding) == 3:
            return (*padding, padding[1])
        if len(padding) == 2:
            return padding * 2
        if len(padding) == 1:
            return padding * 4
        raise PaddingError(f"recieved padding: {padding}")
    ```
    ]]></content>
  </entry>
  <entry>
    <title>standard_config.py</title>

    <id>https://markata.dev/markata/standard-config/</id>
    <link href="https://markata.dev/markata/standard-config/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
Standard Config. A module to load tooling config from a users project space. Inspired from frustrations that some tools have a tool.ini, .tool.ini, setup.cfg,…
    ]]></summary>

    <content type="html"><![CDATA[
---

Standard Config.
A module to load tooling config from a users project space.

Inspired from frustrations that some tools have a tool.ini, .tool.ini,
setup.cfg, or pyproject.toml.  Some allow for global configs, some don't.  Some
properly follow the users home directory, others end up in a weird temp
directory.  Windows home directory is only more confusing.  Some will even
respect the users `$XDG_HOME` directory.

This file is for any project that can be configured in plain text such as `ini`
or `toml` and not requiring a .py file.  Just name your tool and let users put
config where it makes sense to them, no need to figure out resolution order.

## Usage:

``` python
from standard_config import load

# Retrieve any overrides from the user
overrides = {'setting': True}
config = load('my_tool', overrides)
```

## Resolution Order

* First global file with a tool key
* First local file with a tool key
* Environment variables prefixed with `TOOL`
* Overrides

### Tool Specific Ini files

Ini file formats must include a `<tool>` key.

``` ini
[my_tool]
setting = True
```

### pyproject.toml

Toml files must include a `tool.<tool>` key

``` toml
[tool.my_tool]
setting = True
```

### setup.cfg

setup.cfg files must include a `tool:<tool>` key

``` ini
[tool:my_tool]
setting = True
```

### global files to consider

* <home>/tool.ini
* <home>/.tool
* <home>/.tool.ini
* <home>/.config/tool.ini
* <home>/.config/.tool
* <home>/.config/.tool.ini

### local files to consider

* <project_home>/tool.ini
* <project_home>/.tool
* <project_home>/.tool.ini
* <project_home>/pyproject.toml
* <project_home>/setup.cfg

Markata's standard configuration system.

## Configuration Overview

Markata uses a hierarchical configuration system based on Pydantic models. Configuration
can be set through:
1. TOML files
2. Environment variables
3. Command line arguments

# Basic Configuration

Minimal `markata.toml`:
```toml
[markata]
# Site info
title = "My Site"
url = "https://example.com"
description = "Site description"

# Content locations
content_dir = "content"
output_dir = "markout"
assets_dir = "static"

# Plugin management
hooks = ["default"]
```

# Environment Variables

All settings can be overridden with environment variables:
```bash
# Override site URL
export MARKATA_URL="https://staging.example.com"

# Override output directory
export MARKATA_OUTPUT_DIR="dist"

# Enable debug mode
export MARKATA_DEBUG=1
```

# Detailed Configuration

## Core Settings

```toml
[markata]
# Site information
title = "My Site"                  # Site title
url = "https://example.com"        # Base URL
description = "Site description"   # Meta description
author_name = "Author Name"        # Author name
author_email = "me@example.com"    # Author email
icon = "favicon.ico"               # Site icon
lang = "en"                        # Site language

# Content locations
content_dir = "content"           # Source content location
output_dir = "markout"            # Build output location
assets_dir = "static"             # Static assets location
template_dir = "templates"        # Template location

# Plugin management
hooks = ["default"]               # Active plugins
disabled_hooks = []               # Disabled plugins
```

## Cache Settings

```toml
[markata]
# Cache configuration
default_cache_expire = 3600       # Default TTL (1 hour)
template_cache_expire = 86400     # Template TTL (24 hours)
markdown_cache_expire = 21600     # Markdown TTL (6 hours)
dynamic_cache_expire = 3600       # Dynamic TTL (1 hour)
```

## Development Settings

```toml
[markata]
# Development server
dev_server_port = 8000            # Local server port
dev_server_host = "localhost"     # Local server host
debug = false                     # Debug mode

# Performance
parallel = true                   # Enable parallel processing
workers = 4                       # Number of worker threads
```

## Content Settings

```toml
[markata]
# Content processing
default_template = "post.html"    # Default template
markdown_extensions = [           # Markdown extensions
    "fenced_code",
    "tables",
    "footnotes"
]

# Content filtering
draft = false                     # Include drafts
future = false                    # Include future posts
```

# Plugin Configuration

Each plugin can define its own configuration section:

```toml
# RSS feed configuration
[markata.feeds]
rss = { output = "rss.xml" }
atom = { output = "atom.xml" }
json = { output = "feed.json" }

# Template configuration
[markata.template]
engine = "jinja2"
cache_size = 100
autoescape = true

# Markdown configuration
[markata.markdown]
highlight_theme = "monokai"
line_numbers = true
```

## Configuration Validation

The configuration is validated using Pydantic models:

```python
from pydantic import BaseModel, Field

class MarkataConfig(BaseModel):
    """Core configuration model."""
    # Site info
    title: str = Field(..., description="Site title")
    url: str = Field(..., description="Site base URL")

    # Directories
    content_dir: Path = Field("content", description="Content directory")
    output_dir: Path = Field("markout", description="Output directory")

    # Features
    debug: bool = Field(False, description="Enable debug mode")
    parallel: bool = Field(True, description="Enable parallel processing")

    model_config = ConfigDict(
        validate_assignment=True,
        arbitrary_types_allowed=True,
        extra="allow",
        str_strip_whitespace=True,
        validate_default=True,
        populate_by_name=True,
    )
```

# Usage Example

```python
from markata import Markata

# Load config from file
markata = Markata.from_file("markata.toml")

# Access configuration
print(markata.config.title)         # Site title
print(markata.config.url)           # Site URL
print(markata.config.content_dir)   # Content directory

# Access plugin config
print(markata.config.feeds.rss)     # RSS feed config
print(markata.config.template)      # Template config

# Override config
markata.config.debug = True
markata.config.parallel = False
```

See hookspec.py for plugin development and lifecycle.py for build process details.

---

!!! function
    <h2 id="_get_global_path_specs" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">_get_global_path_specs <em class="small">function</em></h2>

    Generate a list of standard pathspecs for global config files.

    Args:
        tool (str): name of the tool to configure

???+ source "_get_global_path_specs <em class='small'>source</em>"
    ```python
    def _get_global_path_specs(tool: str) -> path_spec_type:
        """
        Generate a list of standard pathspecs for global config files.

        Args:
            tool (str): name of the tool to configure
        """
        try:
            home = Path(os.environ["XDG_HOME"])
        except KeyError:
            home = Path.home()

        return [
            {"path_specs": home / f"{tool}.ini", "parser": "ini", "keys": [tool]},
            {"path_specs": home / f".{tool}", "parser": "ini", "keys": [tool]},
            {"path_specs": home / f".{tool}.ini", "parser": "ini", "keys": [tool]},
            {
                "path_specs": home / ".config" / f"{tool}.ini",
                "parser": "ini",
                "keys": [tool],
            },
            {
                "path_specs": home / ".config" / f".{tool}",
                "parser": "ini",
                "keys": [tool],
            },
            {
                "path_specs": home / ".config" / f".{tool}.ini",
                "parser": "ini",
                "keys": [tool],
            },
        ]
    ```
!!! function
    <h2 id="_get_local_path_specs" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">_get_local_path_specs <em class="small">function</em></h2>

    Generate a list of standard pathspecs for local, project directory config files.

    Args:
        tool (str): name of the tool to configure

???+ source "_get_local_path_specs <em class='small'>source</em>"
    ```python
    def _get_local_path_specs(tool: str, project_home: Union[str, Path]) -> path_spec_type:
        """
        Generate a list of standard pathspecs for local, project directory config files.

        Args:
            tool (str): name of the tool to configure
        """
        return [
            {
                "path_specs": Path(project_home) / f"{tool}.ini",
                "parser": "ini",
                "keys": [tool],
            },
            {
                "path_specs": Path(project_home) / f".{tool}",
                "parser": "ini",
                "keys": [tool],
            },
            {
                "path_specs": Path(project_home) / f".{tool}.ini",
                "parser": "ini",
                "keys": [tool],
            },
            {
                "path_specs": Path(project_home) / f"{tool}.yml",
                "parser": "yaml",
                "keys": [tool],
            },
            {
                "path_specs": Path(project_home) / f".{tool}.yml",
                "parser": "yaml",
                "keys": [tool],
            },
            {
                "path_specs": Path(project_home) / f"{tool}.toml",
                "parser": "toml",
                "keys": [tool],
            },
            {
                "path_specs": Path(project_home) / f".{tool}.toml",
                "parser": "toml",
                "keys": [tool],
            },
            {
                "path_specs": Path(project_home) / "pyproject.toml",
                "parser": "toml",
                "keys": ["tool", tool],
            },
            {
                "path_specs": Path(project_home) / "setup.cfg",
                "parser": "ini",
                "keys": [f"tool.{tool}"],
            },
        ]
    ```
!!! function
    <h2 id="_get_attrs" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">_get_attrs <em class="small">function</em></h2>

    Get nested config data from a list of keys.

    specifically written for pyproject.toml which needs to get `tool` then `<tool>`

???+ source "_get_attrs <em class='small'>source</em>"
    ```python
    def _get_attrs(attrs: list, config: Dict) -> Dict:
        """Get nested config data from a list of keys.

        specifically written for pyproject.toml which needs to get `tool` then `<tool>`
        """
        for attr in attrs:
            config = config[attr]
        return config
    ```
!!! function
    <h2 id="_load_config_file" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">_load_config_file <em class="small">function</em></h2>

    Load a configuration file using the appropriate parser.

    Args:
        file_spec: Dictionary containing path_specs, parser, and keys information

    Returns:
        Optional[Dict[str, Any]]: Parsed configuration or None if file doesn't exist

???+ source "_load_config_file <em class='small'>source</em>"
    ```python
    def _load_config_file(file_spec: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Load a configuration file using the appropriate parser.

        Args:
            file_spec: Dictionary containing path_specs, parser, and keys information

        Returns:
            Optional[Dict[str, Any]]: Parsed configuration or None if file doesn't exist
        """
        path = file_spec["path_specs"]
        if not path.exists():
            return None

        try:
            if file_spec["parser"] == "toml":
                with open(path, "rb") as f:
                    config = tomli.load(f)
            elif file_spec["parser"] == "yaml":
                with open(path, "r") as f:
                    config = yaml.safe_load(f)
            elif file_spec["parser"] == "ini":
                config = configparser.ConfigParser()
                config.read(path)
                # Convert ConfigParser to dict
                config = {s: dict(config.items(s)) for s in config.sections()}
            else:
                return None

            return _get_attrs(file_spec["keys"], config)
        except (
            KeyError,
            TypeError,
            yaml.YAMLError,
            tomli.TOMLDecodeError,
            configparser.Error,
        ) as e:
            # warn if var tool name in file name
            if file_spec["keys"][0] in str(path):
                message = f"Failed to load config file: {path}: {e}"
                raise UserWarning(message)

            return None
    ```
!!! function
    <h2 id="_load_files" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">_load_files <em class="small">function</em></h2>

    Load config files stopping at the first one that exists and can be parsed.

    Args:
        config_path_specs: List of path specifications to try

    Returns:
        Dict[str, Any]: Configuration dictionary

???+ source "_load_files <em class='small'>source</em>"
    ```python
    def _load_files(config_path_specs: path_spec_type) -> Dict[str, Any]:
        """Load config files stopping at the first one that exists and can be parsed.

        Args:
            config_path_specs: List of path specifications to try

        Returns:
            Dict[str, Any]: Configuration dictionary
        """
        for file_spec in config_path_specs:
            config = _load_config_file(file_spec)
            if config:
                return config
        return {}
    ```
!!! function
    <h2 id="_load_env" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">_load_env <em class="small">function</em></h2>

    Load config from environment variables.

    Args:
        tool (str): name of the tool to configure

???+ source "_load_env <em class='small'>source</em>"
    ```python
    def _load_env(tool: str) -> Dict[str, Any]:
        """Load config from environment variables.

        Args:
            tool (str): name of the tool to configure
        """
        env_prefix = tool.upper()
        env_config = {
            key.replace(f"{env_prefix}_", "").lower(): value
            for key, value in os.environ.items()
            if key.startswith(f"{env_prefix}_")
        }
        return env_config
    ```
!!! function
    <h2 id="load" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">load <em class="small">function</em></h2>

    Load tool config from standard config files.

    Resolution Order

    * First global file with a tool key
    * First local file with a tool key
    * Environment variables prefixed with `TOOL`
    * Overrides

    Args:
        tool (str): name of the tool to configure
        project_home (Union[Path, str], optional): Project directory to search for config files. Defaults to ".".
        overrides (Dict, optional): Override values to apply last. Defaults to None.

    Returns:
        Dict[str, Any]: Configuration object

???+ source "load <em class='small'>source</em>"
    ```python
    def load(
        tool: str,
        project_home: Union[Path, str] = ".",
        overrides: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """Load tool config from standard config files.

        Resolution Order

        * First global file with a tool key
        * First local file with a tool key
        * Environment variables prefixed with `TOOL`
        * Overrides

        Args:
            tool (str): name of the tool to configure
            project_home (Union[Path, str], optional): Project directory to search for config files. Defaults to ".".
            overrides (Dict, optional): Override values to apply last. Defaults to None.

        Returns:
            Dict[str, Any]: Configuration object
        """
        overrides = overrides or {}
        config = {}

        # Load from files in order of precedence
        config.update(_load_files(_get_global_path_specs(tool)) or {})
        config.update(_load_files(_get_local_path_specs(tool, project_home)) or {})
        config.update(_load_env(tool))
        config.update(overrides)

        # If no settings class is provided, return the raw dict
        return config
    ```
    ]]></content>
  </entry>
  <entry>
    <title>to_json.py</title>

    <id>https://markata.dev/markata/plugins/to-json/</id>
    <link href="https://markata.dev/markata/plugins/to-json/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
None
    ]]></summary>

    <content type="html"><![CDATA[
---

None

---
    ]]></content>
  </entry>
  <entry>
    <title>sitemap.py</title>

    <id>https://markata.dev/markata/plugins/sitemap/</id>
    <link href="https://markata.dev/markata/plugins/sitemap/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
[DEPRECATED] The plugin is deprecated and will be removed in a future version. Please use instead, which provides more comprehensive sitemap generation…
    ]]></summary>

    <content type="html"><![CDATA[
---

[DEPRECATED] The `markata.plugins.sitemap` plugin is deprecated and will be removed in a
future version. Please use `markata.plugins.feeds` instead, which provides more
comprehensive sitemap generation capabilities.

## Installation

This plugin is deprecated. Use `markata.plugins.feeds` instead:

```toml
hooks = [
    "markata.plugins.feeds",  # Use this instead
    # "markata.plugins.sitemap",  # Deprecated
]
```

# Migration Guide

To migrate to the new feeds plugin:

1. Remove sitemap plugin from hooks:
```toml
# Remove or comment out
# "markata.plugins.sitemap"
```

2. Add feeds plugin:
```toml
hooks = [
    "markata.plugins.feeds"
]
```

3. Update configuration:
```toml
[markata.feeds]
# Sitemap configuration
sitemap = { output = "sitemap.xml" }

# Optional: Configure sitemap settings
[markata.feeds.sitemap.options]
changefreq = "daily"
priority = "0.7"
```

See the feeds plugin documentation for more configuration options.

# Legacy Configuration

If you must continue using this plugin temporarily, configure in `markata.toml`:

```toml
[markata]
url = "https://example.com"

[markata.sitemap]
changefreq = "daily"
priority = "0.7"
```

# Dependencies

This plugin depends on:
- pydantic for configuration

WARNING: This plugin is deprecated and will be removed in a future version.
Please migrate to `markata.plugins.feeds` as soon as possible.

---

!!! class
    <h2 id="SiteMapUrl" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">SiteMapUrl <em class="small">class</em></h2>

    [DEPRECATED] A model representing a URL entry in the sitemap.xml file.

    WARNING: This class is part of the deprecated sitemap plugin. Please migrate to
    the feeds plugin which provides more comprehensive sitemap generation capabilities.

    To configure the base URL for your site, set the 'url' field in your markata config:
    ```yaml
    url: https://example.com
    ```

    If no base URL is set, relative URLs will be used.

???+ source "SiteMapUrl <em class='small'>source</em>"
    ```python
    class SiteMapUrl(pydantic.BaseModel):
        """[DEPRECATED] A model representing a URL entry in the sitemap.xml file.

        WARNING: This class is part of the deprecated sitemap plugin. Please migrate to
        the feeds plugin which provides more comprehensive sitemap generation capabilities.

        To configure the base URL for your site, set the 'url' field in your markata config:
        ```yaml
        url: https://example.com
        ```

        If no base URL is set, relative URLs will be used.
        """

        slug: str = Field(..., exclude=True)
        loc: str = Field(
            None,
            include=True,
            description="The full URL for this page in the sitemap. Generated automatically from config.url + slug.",
        )
        changefreq: str = Field("daily", include=True)
        priority: str = Field("0.7", include=True)
        markata: Any = Field(None, exclude=True)

        model_config = pydantic.ConfigDict(
            validate_assignment=False,
            arbitrary_types_allowed=True,
            extra="allow",
            str_strip_whitespace=True,
            validate_default=True,
            coerce_numbers_to_str=True,
            populate_by_name=True,
        )

        @pydantic.field_validator("loc", mode="before")
        @classmethod
        def validate_loc(cls, v, info) -> str:
            """Generate the URL for the sitemap entry.

            Uses markata.config.url as the base URL if set, otherwise uses relative URLs.
            Example: https://example.com/my-page/ or /my-page/
            """
            if v is None:
                markata = info.data.get("markata")
                slug = info.data.get("slug")
                if markata is None or slug is None:
                    raise ValueError(
                        "Could not generate sitemap URL: markata and slug are required. "
                        "This usually means the Post model is missing required fields. "
                        "Check that your post has a valid slug and markata instance."
                    )

                # Get base URL from config, default to empty string if not set
                base_url = getattr(markata.config, "url", "")
                if not base_url:
                    return f"/{slug}/"

                # Ensure URL has a trailing slash for consistency
                return f"{base_url.rstrip('/')}/{slug}/"
            return v

        def dict(self, *args, **kwargs):
            return {"url": {**super().dict(*args, **kwargs)}}
    ```
!!! class
    <h2 id="SiteMapPost" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">SiteMapPost <em class="small">class</em></h2>

    [DEPRECATED] A model for posts that will be included in the sitemap.

    WARNING: This class is part of the deprecated sitemap plugin. Please migrate to
    the feeds plugin which provides more comprehensive sitemap generation capabilities.

    To configure the base URL for your site, set the 'url' field in your markata config:
    ```yaml
    url: https://example.com
    ```

???+ source "SiteMapPost <em class='small'>source</em>"
    ```python
    class SiteMapPost(pydantic.BaseModel):
        """[DEPRECATED] A model for posts that will be included in the sitemap.

        WARNING: This class is part of the deprecated sitemap plugin. Please migrate to
        the feeds plugin which provides more comprehensive sitemap generation capabilities.

        To configure the base URL for your site, set the 'url' field in your markata config:
        ```yaml
        url: https://example.com
        ```
        """

        slug: str = None
        published: bool = True
        sitemap_url: Optional[SiteMapUrl] = None
        markata: Any = Field(None, exclude=True)

        model_config = pydantic.ConfigDict(
            validate_assignment=False,
            arbitrary_types_allowed=True,
            extra="allow",
            str_strip_whitespace=True,
            validate_default=True,
            coerce_numbers_to_str=True,
            populate_by_name=True,
        )

        @pydantic.field_validator("sitemap_url", mode="before")
        @classmethod
        def validate_sitemap_url(cls, v, info) -> Optional[SiteMapUrl]:
            """Initialize sitemap_url if not provided."""
            markata = info.data.get("markata")
            slug = info.data.get("slug")
            if markata is None or slug is None:
                raise ValueError(
                    "Could not create sitemap entry: markata and slug are required. "
                    "This usually means the Post model is missing required fields. "
                    "Check that your post has a valid slug and markata instance."
                )

            if v is None:
                return SiteMapUrl(markata=markata, slug=slug)
            if isinstance(v, dict):
                return SiteMapUrl(**v, markata=markata, slug=slug)
            if v.markata is None:
                v.markata = markata
            if v.slug is None:
                v.slug = slug
            return v
    ```
!!! method
    <h2 id="validate_loc" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">validate_loc <em class="small">method</em></h2>

    Generate the URL for the sitemap entry.

    Uses markata.config.url as the base URL if set, otherwise uses relative URLs.
    Example: https://example.com/my-page/ or /my-page/

???+ source "validate_loc <em class='small'>source</em>"
    ```python
    def validate_loc(cls, v, info) -> str:
            """Generate the URL for the sitemap entry.

            Uses markata.config.url as the base URL if set, otherwise uses relative URLs.
            Example: https://example.com/my-page/ or /my-page/
            """
            if v is None:
                markata = info.data.get("markata")
                slug = info.data.get("slug")
                if markata is None or slug is None:
                    raise ValueError(
                        "Could not generate sitemap URL: markata and slug are required. "
                        "This usually means the Post model is missing required fields. "
                        "Check that your post has a valid slug and markata instance."
                    )

                # Get base URL from config, default to empty string if not set
                base_url = getattr(markata.config, "url", "")
                if not base_url:
                    return f"/{slug}/"

                # Ensure URL has a trailing slash for consistency
                return f"{base_url.rstrip('/')}/{slug}/"
            return v
    ```
!!! method
    <h2 id="validate_sitemap_url" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">validate_sitemap_url <em class="small">method</em></h2>

    Initialize sitemap_url if not provided.

???+ source "validate_sitemap_url <em class='small'>source</em>"
    ```python
    def validate_sitemap_url(cls, v, info) -> Optional[SiteMapUrl]:
            """Initialize sitemap_url if not provided."""
            markata = info.data.get("markata")
            slug = info.data.get("slug")
            if markata is None or slug is None:
                raise ValueError(
                    "Could not create sitemap entry: markata and slug are required. "
                    "This usually means the Post model is missing required fields. "
                    "Check that your post has a valid slug and markata instance."
                )

            if v is None:
                return SiteMapUrl(markata=markata, slug=slug)
            if isinstance(v, dict):
                return SiteMapUrl(**v, markata=markata, slug=slug)
            if v.markata is None:
                v.markata = markata
            if v.slug is None:
                v.slug = slug
            return v
    ```
    ]]></content>
  </entry>
  <entry>
    <title>base_cli.py</title>

    <id>https://markata.dev/markata/plugins/base-cli/</id>
    <link href="https://markata.dev/markata/plugins/base-cli/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin provides Markata's core command-line interface functionality, including essential commands like , , and . Installation This plugin is built-in and…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.base_cli` plugin provides Markata's core command-line interface
functionality, including essential commands like `build`, `list`, and `clean`.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.base_cli",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.base_cli",
]
```

## Configuration

No explicit configuration is required. The plugin automatically registers CLI commands.

## Functionality

## Core Commands

### Build Command

Build your Markata site:
```bash
markata build [options]

# Options:
--clean         Clean output directory first
--watch         Watch for changes and rebuild
--serve         Start development server
--profile       Profile the build process
--debug         Enable debug mode
```

### List Command

List and filter articles:
```bash
markata list [options]

# Options:
--filter "post.published"  Filter posts by expression
--sort "post.date"        Sort posts by attribute
--reverse                 Reverse sort order
--format "{title}"        Custom output format
```

### Clean Command

Clean build artifacts:
```bash
markata clean [options]

# Options:
--dry-run      Show what would be deleted
--quiet        Suppress output
```

## Debug Features

The plugin provides:
- Pretty error formatting
- Post-mortem debugging
- Performance profiling
- Verbose logging

## Development Server

Features include:
- Live reload
- Asset serving
- Port configuration
- Host configuration

## Watch Mode

Supports:
- File watching
- Auto-rebuild
- Pattern matching
- Debouncing

## Dependencies

This plugin depends on:
- typer for CLI interface
- rich for terminal output
- watchfiles for watch mode

---

!!! function
    <h2 id="make_pretty" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">make_pretty <em class="small">function</em></h2>

    This is a helper function that enables suppresses tracebacks from
    frameworks like `click` that can make your traceback long and hard
    to follow.  It also makes evrerything more colorful and easier to
    follow.

???+ source "make_pretty <em class='small'>source</em>"
    ```python
    def make_pretty() -> None:
        """
        This is a helper function that enables suppresses tracebacks from
        frameworks like `click` that can make your traceback long and hard
        to follow.  It also makes evrerything more colorful and easier to
        follow.
        """
        import click
        import pluggy
        import typer
        from rich import pretty as _pretty
        from rich import traceback

        _pretty.install()
        traceback.install(
            show_locals=True,
            suppress=[
                pluggy,
                click,
                typer,
            ],
        )
    ```
!!! function
    <h2 id="cli" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">cli <em class="small">function</em></h2>

    Markata hook to implement base cli commands.

???+ source "cli <em class='small'>source</em>"
    ```python
    def cli(app: typer.Typer, markata: "Markata") -> None:
        """
        Markata hook to implement base cli commands.
        """

        plugins_app = typer.Typer()
        config_app = typer.Typer()
        app.add_typer(plugins_app, name="plugins")
        app.add_typer(config_app, name="config")

        @app.command()
        def tui(ctx: typer.Context) -> None:
            try:
                from trogon import Trogon
                from typer.main import get_group
            except ImportError:
                typer.echo("trogon not installed")
                typer.echo(
                    "install markata with optional tui group to use tui `pip install 'markata[tui]'`"
                )
                return

            Trogon(get_group(app), click_context=ctx).run()

        @plugins_app.callback()
        def plugins():
            "create new things from templates"

        @config_app.callback()
        def config():
            "configuration management"

        @config_app.command()
        def show(
            verbose: bool = typer.Option(
                False,
                "--verbose",
                "-v",
            ),
        ) -> None:
            if verbose:
                markata.console.quiet = False
            else:
                markata.console.quiet = True
            rich_print(markata.config)

        @config_app.command()
        def generate(
            verbose: bool = typer.Option(
                False,
                "--verbose",
                "-v",
            ),
        ) -> None:
            if verbose:
                markata.console.quiet = False
            else:
                markata.console.quiet = True

            rich_print(toml.dumps(json.loads(markata.config.model_dump())))

        @config_app.command()
        def get(key: str) -> None:
            keys = key.split(".")
            markata.console.quiet = True
            keys_processed = ""
            value = markata.config
            na = Literal["na"]
            for key in keys:
                value = getattr(value, key, na)
                keys_processed = f"{keys_processed}.{key}".strip(".")
                if value is na:
                    rich_print(f"{keys_processed} not found")
                    sys.exit(1)

            rich_print(value)

        new_app = typer.Typer()
        app.add_typer(new_app, name="new")

        @new_app.callback()
        def new():
            "create new things from templates"

        @new_app.command()
        def blog(
            directory: Path = typer.Argument(
                ...,
                help="The directory to create the blog in.",
            ),
        ) -> None:
            """
            Create a new blog from using the template from
            https://github.com/WaylonWalker/markata-blog-starter.
            """

            from copier import run_copy

            typer.echo(f"creating a new project in {directory.absolute()}")
            url = markata.config.get("starters", {}).get(
                "blog",
                "git+https://github.com/WaylonWalker/markata-blog-starter",
            )
            run_copy(url, directory)

        @new_app.command()
        def post() -> None:
            """
            Create new blog post in the pages directory from the template at
            https://github.com/WaylonWalker/markata-post-template.
            """

            print("create a new post")
            from copier import run_copy

            typer.echo(f"creating a new post in {Path().absolute()}/posts")
            url = markata.config.get("starters", {}).get(
                "post",
                "git+https://github.com/WaylonWalker/markata-post-template",
            )
            run_copy(url, Path("."))

        @new_app.command()
        def plugin() -> None:
            """
            Create a new plugin using the template at
            https://github.com/WaylonWalker/markata-plugin-template.
            """
            from copier import run_copy

            typer.echo(
                f"creating a new plugin in {Path().absolute()}"
                f"/<python-package-name>/plugins",
            )
            url = markata.config.get("starters", {}).get(
                "post",
                "git+https://github.com/WaylonWalker/markata-plugin-template",
            )
            run_copy(url, Path("."))

        @app.command()
        def build(
            pretty: bool = True,
            quiet: bool = typer.Option(
                False,
                "--quiet",
                "-q",
            ),
            verbose: bool = typer.Option(
                False,
                "--verbose",
                "-v",
            ),
            should_pdb: bool = typer.Option(
                False,
                "--pdb",
            ),
            profile: bool = True,
        ) -> None:
            """
            Markata's primary way of building your site for production.
            By default, running `markta build` will render your markdown to
            the `./markout` directory.

            ``` bash
            markata build
            ```

            If you are having an issue and want to pop immediately into a debugger
            upon failure you can pass the `--pdb` flag to the build command.

            ``` bash
            markata build  --pdb
            ```

            If you do not like the way rich looks, or its suppressing tracebaks you
            would like to remain visible you can use `--no-pretty`

            ``` bash
            markata build --no-pretty
            ```

            If you need to run without any console logging pass in the
            `--quiet` flag.

            ``` bash
            markata build --quiet
            ```

            `markta build` will automatically run the pyinstrument profiler
            while building your site if you have pyinstrument installed.  It
            will echo out your profile in the console as well as write it to
            `/_profile` on your built site. If you prefer not to run
            pyinstrument profiling, even when it is installed you can pass
            in `--no-profile`

            ``` bash
            markata build --no-profile
            ```
            """

            if pretty:
                make_pretty()

            if quiet:
                markata.console.quiet = True

            if verbose:
                markata.console.print("console options:", markata.console.options)

            if not profile:
                markata.config.profiler.should_profile = False

            if should_pdb:
                pdb_run(markata.run)

            else:
                markata.console.log("[purple]starting the build")
                markata.run()

        @app.command()
        def list(
            map: str = "title",
            filter: str = "True",
            sort: str = "True",
            head: Optional[int] = None,
            tail: Optional[int] = None,
            include_empty: bool = False,
            reverse: bool = False,
            use_pager: bool = typer.Option(True, "--pager", "--no-pager"),
        ) -> None:
            """
            Provides a way run markatas, map, filter, and sort from the
            command line.  I personally use this more often than the build
            command while I am writing on a site with a large number of
            posts on it.  It makes slicing in by `templatekey`, `tag`, or
            `date` much easier.

            # default list

            By default `markata list` will list all titles in a pager, for all posts
            being loaded by markata.

            ``` bash
            markata list
            ```

            # Skip the pager

            Markata uses rich for its pager, it's pretty smart about when to
            use the pager or pass text to the next thing in the pipeline,
            but if you don't want to run a pager you can pass  `--no-pager`

            ``` bash
            markata list --no-pager
            ```

            # List other attributes

            You can list any other attribute tied to your posts.  These are
            added through either your yaml frontmatter at the start of your
            post, or through the use of a plugin.

            ``` bash
            # the filepath of the post
            markata list --map path

            # the slug of the post (where it will show up on the site)
            markata list --map slug

            # the date of the post
            markata list --map date

            # the full raw content of the post
            markata list --map content
            ```

            # List more than one attribute

            You can create new attributes as you map to echo out by
            combining existing attributes.

            ``` bash
            markata list --map 'title + " , " + slug'
            ```

            # Using Python objects as map

            You can access attributes of each post attribute that you map
            over.  For instance on my blog, each post has a date that is a
            datetime object.  I can ask each post for its `date.year`

            ``` bash
            markata list --map date.year

            # combining this with title
            markata list --map 'str(date.year) + "," + title'
            ```

            # Filtering posts

            Posts are filtered with python syntax, you will have all
            attributes tied to your posts available to filter with.

            ``` bash
            markata list --filter "'__' not in title"
            ```

            # Filtering by dates

            If your site has dates tied to your posts you can filter by
            date.  On my blog this makes a ton of sense and is quite useful.
            On the Markata docs though it doesn't really make much sense,
            since there really isn't the idea of a post date there.

            ``` bash
            # listing today's posts
            markata list --filter "date==today"

            # listing this year's posts
            markata list --filter "date.year==today.year"
            ```

            # Full Content Search

            You can also search the full content of each post for specific
            words.
            ``` bash

            markata list --filter "'python' in content"
            ```

            # Filtering by frontmatter data

            I use a templateKey on my personal blog to determine which
            template to render the page with.  I can fitler my posts by a
            `til` (today i learned) key.

            ``` bash
            markata list --filter "templateKey=='til'"
            ```

            # Combining filters

            Filters can be combined together quite like maps can, it's all
            just python syntax.

            ``` bash
            markata list --filter "templateKey=='til' and date == today"
            ```

            # Sorting posts

            Posts can be sorted by attributes on your post, and they can
            even be reversed.

            ``` bash
            markta list --sort date
            markta list --sort date --reverse
            ```

            # Putting it all together

            The real power of all this comes when you combine them all into
            lists that work for you and your workflow.  This really makes
            working on larger projects so much easier to find things.

            # Making a fuzzy picker for your posts

            Here is a bash command to open an fzf picker for todays posts,
            then open it in your `$EDITOR`

            ``` bash
            markata list \
                    --map path\
                    --filter 'date==today'\
                    --sort date\
                    --reverse |\
                    fzf --preview 'bat --color always {}' |\
                    xargs -I {} $EDITOR {}
            ```

            # Combining wtih nvim Telescope

            Here is the same command setup as a Telescope picker for neovim.

            ``` vim
            nnoremap <leader>et <cmd>Telescope find_files find_command=markata,list,--map,path,--filter,date==today<cr>
            ```

            If you have another way to open posts in your editor with
            `markata list` I would love to accept a PR to add it to the
            examples here.
            """

            markata.console.quiet = True

            tail = -tail if tail else tail
            filtered = markata.map(map, filter, sort)
            if not include_empty:
                filtered = [a for a in filtered if a != ""]
            filtered = filtered[tail:head]
            if reverse:
                filtered = reversed(filtered)

            class Posts(pydantic.RootModel):
                root: List[markata.Post]

            markata.console.quiet = False
            if markata.console.is_terminal and use_pager:
                with markata.console.pager():
                    for a in filtered:
                        markata.console.print(a, style="purple")
            else:
                for a in filtered:
                    markata.console.print(a)

        @app.command()
        def clean(
            quiet: bool = typer.Option(
                False,
                "--quiet",
                "-q",
            ),
            dry_run: bool = typer.Option(
                False,
                "--dry-run",
            ),
        ):
            """
            Cleans up output generated by markata including both the output_dir and
            the .markata_cache.

            # Dry Run

            You can run with `--dry-run` to see what markata is about to do.

            ``` bash
            markata clean --dry-run
            [09:42:37] [DRYRUN] removing outptut directory: markout base_cli.py:371
                       [DRYRUN] removing cache directory: .markata.cache base_cli.py:377

            ```

            # Running clean

            Running markata clean will fully delete all of the directories created
            by markata.

            ``` bash
            markata clean
            [09:53:04]  removing outptut directory: markout base_cli.py:394
                        removing cache directory: .markata.cache base_cli.py:405
            ```

            # Running Quietly

            Running with `--quiet` will remove all of the directories created by
            markata without announcing what it is doing.

            ``` bash
            markata clean --quiet
            ```
            """
            _clean(markata=markata, quiet=quiet, dry_run=dry_run)
    ```
!!! function
    <h2 id="pdb_run" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">pdb_run <em class="small">function</em></h2>

    Wraps a function call with a post_mortem pdb debugger.

???+ source "pdb_run <em class='small'>source</em>"
    ```python
    def pdb_run(func: Callable) -> None:
        """
        Wraps a function call with a post_mortem pdb debugger.
        """
        try:
            func()
        except Exception:
            extype, value, tb = sys.exc_info()
            traceback.print_exc()
            pdb.post_mortem(tb)
    ```
!!! function
    <h2 id="plugins" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">plugins <em class="small">function</em></h2>

    create new things from templates

???+ source "plugins <em class='small'>source</em>"
    ```python
    def plugins():
            "create new things from templates"
    ```
!!! function
    <h2 id="config" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">config <em class="small">function</em></h2>

    configuration management

???+ source "config <em class='small'>source</em>"
    ```python
    def config():
            "configuration management"
    ```
!!! function
    <h2 id="new" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">new <em class="small">function</em></h2>

    create new things from templates

???+ source "new <em class='small'>source</em>"
    ```python
    def new():
            "create new things from templates"
    ```
!!! function
    <h2 id="blog" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">blog <em class="small">function</em></h2>

    Create a new blog from using the template from
    https://github.com/WaylonWalker/markata-blog-starter.

???+ source "blog <em class='small'>source</em>"
    ```python
    def blog(
            directory: Path = typer.Argument(
                ...,
                help="The directory to create the blog in.",
            ),
        ) -> None:
            """
            Create a new blog from using the template from
            https://github.com/WaylonWalker/markata-blog-starter.
            """

            from copier import run_copy

            typer.echo(f"creating a new project in {directory.absolute()}")
            url = markata.config.get("starters", {}).get(
                "blog",
                "git+https://github.com/WaylonWalker/markata-blog-starter",
            )
            run_copy(url, directory)
    ```
!!! function
    <h2 id="post" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">post <em class="small">function</em></h2>

    Create new blog post in the pages directory from the template at
    https://github.com/WaylonWalker/markata-post-template.

???+ source "post <em class='small'>source</em>"
    ```python
    def post() -> None:
            """
            Create new blog post in the pages directory from the template at
            https://github.com/WaylonWalker/markata-post-template.
            """

            print("create a new post")
            from copier import run_copy

            typer.echo(f"creating a new post in {Path().absolute()}/posts")
            url = markata.config.get("starters", {}).get(
                "post",
                "git+https://github.com/WaylonWalker/markata-post-template",
            )
            run_copy(url, Path("."))
    ```
!!! function
    <h2 id="plugin" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">plugin <em class="small">function</em></h2>

    Create a new plugin using the template at
    https://github.com/WaylonWalker/markata-plugin-template.

???+ source "plugin <em class='small'>source</em>"
    ```python
    def plugin() -> None:
            """
            Create a new plugin using the template at
            https://github.com/WaylonWalker/markata-plugin-template.
            """
            from copier import run_copy

            typer.echo(
                f"creating a new plugin in {Path().absolute()}"
                f"/<python-package-name>/plugins",
            )
            url = markata.config.get("starters", {}).get(
                "post",
                "git+https://github.com/WaylonWalker/markata-plugin-template",
            )
            run_copy(url, Path("."))
    ```
!!! function
    <h2 id="build" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">build <em class="small">function</em></h2>

    Markata's primary way of building your site for production.
    By default, running `markta build` will render your markdown to
    the `./markout` directory.

    ``` bash
    markata build
    ```

    If you are having an issue and want to pop immediately into a debugger
    upon failure you can pass the `--pdb` flag to the build command.

    ``` bash
    markata build  --pdb
    ```

    If you do not like the way rich looks, or its suppressing tracebaks you
    would like to remain visible you can use `--no-pretty`

    ``` bash
    markata build --no-pretty
    ```

    If you need to run without any console logging pass in the
    `--quiet` flag.

    ``` bash
    markata build --quiet
    ```

    `markta build` will automatically run the pyinstrument profiler
    while building your site if you have pyinstrument installed.  It
    will echo out your profile in the console as well as write it to
    `/_profile` on your built site. If you prefer not to run
    pyinstrument profiling, even when it is installed you can pass
    in `--no-profile`

    ``` bash
    markata build --no-profile
    ```

???+ source "build <em class='small'>source</em>"
    ```python
    def build(
            pretty: bool = True,
            quiet: bool = typer.Option(
                False,
                "--quiet",
                "-q",
            ),
            verbose: bool = typer.Option(
                False,
                "--verbose",
                "-v",
            ),
            should_pdb: bool = typer.Option(
                False,
                "--pdb",
            ),
            profile: bool = True,
        ) -> None:
            """
            Markata's primary way of building your site for production.
            By default, running `markta build` will render your markdown to
            the `./markout` directory.

            ``` bash
            markata build
            ```

            If you are having an issue and want to pop immediately into a debugger
            upon failure you can pass the `--pdb` flag to the build command.

            ``` bash
            markata build  --pdb
            ```

            If you do not like the way rich looks, or its suppressing tracebaks you
            would like to remain visible you can use `--no-pretty`

            ``` bash
            markata build --no-pretty
            ```

            If you need to run without any console logging pass in the
            `--quiet` flag.

            ``` bash
            markata build --quiet
            ```

            `markta build` will automatically run the pyinstrument profiler
            while building your site if you have pyinstrument installed.  It
            will echo out your profile in the console as well as write it to
            `/_profile` on your built site. If you prefer not to run
            pyinstrument profiling, even when it is installed you can pass
            in `--no-profile`

            ``` bash
            markata build --no-profile
            ```
            """

            if pretty:
                make_pretty()

            if quiet:
                markata.console.quiet = True

            if verbose:
                markata.console.print("console options:", markata.console.options)

            if not profile:
                markata.config.profiler.should_profile = False

            if should_pdb:
                pdb_run(markata.run)

            else:
                markata.console.log("[purple]starting the build")
                markata.run()
    ```
!!! function
    <h2 id="list" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">list <em class="small">function</em></h2>

    Provides a way run markatas, map, filter, and sort from the
    command line.  I personally use this more often than the build
    command while I am writing on a site with a large number of
    posts on it.  It makes slicing in by `templatekey`, `tag`, or
    `date` much easier.

    # default list

    By default `markata list` will list all titles in a pager, for all posts
    being loaded by markata.

    ``` bash
    markata list
    ```

    # Skip the pager

    Markata uses rich for its pager, it's pretty smart about when to
    use the pager or pass text to the next thing in the pipeline,
    but if you don't want to run a pager you can pass  `--no-pager`

    ``` bash
    markata list --no-pager
    ```

    # List other attributes

    You can list any other attribute tied to your posts.  These are
    added through either your yaml frontmatter at the start of your
    post, or through the use of a plugin.

    ``` bash
    # the filepath of the post
    markata list --map path

    # the slug of the post (where it will show up on the site)
    markata list --map slug

    # the date of the post
    markata list --map date

    # the full raw content of the post
    markata list --map content
    ```

    # List more than one attribute

    You can create new attributes as you map to echo out by
    combining existing attributes.

    ``` bash
    markata list --map 'title + " , " + slug'
    ```

    # Using Python objects as map

    You can access attributes of each post attribute that you map
    over.  For instance on my blog, each post has a date that is a
    datetime object.  I can ask each post for its `date.year`

    ``` bash
    markata list --map date.year

    # combining this with title
    markata list --map 'str(date.year) + "," + title'
    ```

    # Filtering posts

    Posts are filtered with python syntax, you will have all
    attributes tied to your posts available to filter with.

    ``` bash
    markata list --filter "'__' not in title"
    ```

    # Filtering by dates

    If your site has dates tied to your posts you can filter by
    date.  On my blog this makes a ton of sense and is quite useful.
    On the Markata docs though it doesn't really make much sense,
    since there really isn't the idea of a post date there.

    ``` bash
    # listing today's posts
    markata list --filter "date==today"

    # listing this year's posts
    markata list --filter "date.year==today.year"
    ```

    # Full Content Search

    You can also search the full content of each post for specific
    words.
    ``` bash

    markata list --filter "'python' in content"
    ```

    # Filtering by frontmatter data

    I use a templateKey on my personal blog to determine which
    template to render the page with.  I can fitler my posts by a
    `til` (today i learned) key.

    ``` bash
    markata list --filter "templateKey=='til'"
    ```

    # Combining filters

    Filters can be combined together quite like maps can, it's all
    just python syntax.

    ``` bash
    markata list --filter "templateKey=='til' and date == today"
    ```

    # Sorting posts

    Posts can be sorted by attributes on your post, and they can
    even be reversed.

    ``` bash
    markta list --sort date
    markta list --sort date --reverse
    ```

    # Putting it all together

    The real power of all this comes when you combine them all into
    lists that work for you and your workflow.  This really makes
    working on larger projects so much easier to find things.

    # Making a fuzzy picker for your posts

    Here is a bash command to open an fzf picker for todays posts,
    then open it in your `$EDITOR`

    ``` bash
    markata list                 --map path                --filter 'date==today'                --sort date                --reverse |                fzf --preview 'bat --color always {}' |                xargs -I {} $EDITOR {}
    ```

    # Combining wtih nvim Telescope

    Here is the same command setup as a Telescope picker for neovim.

    ``` vim
    nnoremap <leader>et <cmd>Telescope find_files find_command=markata,list,--map,path,--filter,date==today<cr>
    ```

    If you have another way to open posts in your editor with
    `markata list` I would love to accept a PR to add it to the
    examples here.

???+ source "list <em class='small'>source</em>"
    ```python
    def list(
            map: str = "title",
            filter: str = "True",
            sort: str = "True",
            head: Optional[int] = None,
            tail: Optional[int] = None,
            include_empty: bool = False,
            reverse: bool = False,
            use_pager: bool = typer.Option(True, "--pager", "--no-pager"),
        ) -> None:
            """
            Provides a way run markatas, map, filter, and sort from the
            command line.  I personally use this more often than the build
            command while I am writing on a site with a large number of
            posts on it.  It makes slicing in by `templatekey`, `tag`, or
            `date` much easier.

            # default list

            By default `markata list` will list all titles in a pager, for all posts
            being loaded by markata.

            ``` bash
            markata list
            ```

            # Skip the pager

            Markata uses rich for its pager, it's pretty smart about when to
            use the pager or pass text to the next thing in the pipeline,
            but if you don't want to run a pager you can pass  `--no-pager`

            ``` bash
            markata list --no-pager
            ```

            # List other attributes

            You can list any other attribute tied to your posts.  These are
            added through either your yaml frontmatter at the start of your
            post, or through the use of a plugin.

            ``` bash
            # the filepath of the post
            markata list --map path

            # the slug of the post (where it will show up on the site)
            markata list --map slug

            # the date of the post
            markata list --map date

            # the full raw content of the post
            markata list --map content
            ```

            # List more than one attribute

            You can create new attributes as you map to echo out by
            combining existing attributes.

            ``` bash
            markata list --map 'title + " , " + slug'
            ```

            # Using Python objects as map

            You can access attributes of each post attribute that you map
            over.  For instance on my blog, each post has a date that is a
            datetime object.  I can ask each post for its `date.year`

            ``` bash
            markata list --map date.year

            # combining this with title
            markata list --map 'str(date.year) + "," + title'
            ```

            # Filtering posts

            Posts are filtered with python syntax, you will have all
            attributes tied to your posts available to filter with.

            ``` bash
            markata list --filter "'__' not in title"
            ```

            # Filtering by dates

            If your site has dates tied to your posts you can filter by
            date.  On my blog this makes a ton of sense and is quite useful.
            On the Markata docs though it doesn't really make much sense,
            since there really isn't the idea of a post date there.

            ``` bash
            # listing today's posts
            markata list --filter "date==today"

            # listing this year's posts
            markata list --filter "date.year==today.year"
            ```

            # Full Content Search

            You can also search the full content of each post for specific
            words.
            ``` bash

            markata list --filter "'python' in content"
            ```

            # Filtering by frontmatter data

            I use a templateKey on my personal blog to determine which
            template to render the page with.  I can fitler my posts by a
            `til` (today i learned) key.

            ``` bash
            markata list --filter "templateKey=='til'"
            ```

            # Combining filters

            Filters can be combined together quite like maps can, it's all
            just python syntax.

            ``` bash
            markata list --filter "templateKey=='til' and date == today"
            ```

            # Sorting posts

            Posts can be sorted by attributes on your post, and they can
            even be reversed.

            ``` bash
            markta list --sort date
            markta list --sort date --reverse
            ```

            # Putting it all together

            The real power of all this comes when you combine them all into
            lists that work for you and your workflow.  This really makes
            working on larger projects so much easier to find things.

            # Making a fuzzy picker for your posts

            Here is a bash command to open an fzf picker for todays posts,
            then open it in your `$EDITOR`

            ``` bash
            markata list \
                    --map path\
                    --filter 'date==today'\
                    --sort date\
                    --reverse |\
                    fzf --preview 'bat --color always {}' |\
                    xargs -I {} $EDITOR {}
            ```

            # Combining wtih nvim Telescope

            Here is the same command setup as a Telescope picker for neovim.

            ``` vim
            nnoremap <leader>et <cmd>Telescope find_files find_command=markata,list,--map,path,--filter,date==today<cr>
            ```

            If you have another way to open posts in your editor with
            `markata list` I would love to accept a PR to add it to the
            examples here.
            """

            markata.console.quiet = True

            tail = -tail if tail else tail
            filtered = markata.map(map, filter, sort)
            if not include_empty:
                filtered = [a for a in filtered if a != ""]
            filtered = filtered[tail:head]
            if reverse:
                filtered = reversed(filtered)

            class Posts(pydantic.RootModel):
                root: List[markata.Post]

            markata.console.quiet = False
            if markata.console.is_terminal and use_pager:
                with markata.console.pager():
                    for a in filtered:
                        markata.console.print(a, style="purple")
            else:
                for a in filtered:
                    markata.console.print(a)
    ```
!!! function
    <h2 id="clean" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">clean <em class="small">function</em></h2>

    Cleans up output generated by markata including both the output_dir and
    the .markata_cache.

    # Dry Run

    You can run with `--dry-run` to see what markata is about to do.

    ``` bash
    markata clean --dry-run
    [09:42:37] [DRYRUN] removing outptut directory: markout base_cli.py:371
               [DRYRUN] removing cache directory: .markata.cache base_cli.py:377

    ```

    # Running clean

    Running markata clean will fully delete all of the directories created
    by markata.

    ``` bash
    markata clean
    [09:53:04]  removing outptut directory: markout base_cli.py:394
                removing cache directory: .markata.cache base_cli.py:405
    ```

    # Running Quietly

    Running with `--quiet` will remove all of the directories created by
    markata without announcing what it is doing.

    ``` bash
    markata clean --quiet
    ```

???+ source "clean <em class='small'>source</em>"
    ```python
    def clean(
            quiet: bool = typer.Option(
                False,
                "--quiet",
                "-q",
            ),
            dry_run: bool = typer.Option(
                False,
                "--dry-run",
            ),
        ):
            """
            Cleans up output generated by markata including both the output_dir and
            the .markata_cache.

            # Dry Run

            You can run with `--dry-run` to see what markata is about to do.

            ``` bash
            markata clean --dry-run
            [09:42:37] [DRYRUN] removing outptut directory: markout base_cli.py:371
                       [DRYRUN] removing cache directory: .markata.cache base_cli.py:377

            ```

            # Running clean

            Running markata clean will fully delete all of the directories created
            by markata.

            ``` bash
            markata clean
            [09:53:04]  removing outptut directory: markout base_cli.py:394
                        removing cache directory: .markata.cache base_cli.py:405
            ```

            # Running Quietly

            Running with `--quiet` will remove all of the directories created by
            markata without announcing what it is doing.

            ``` bash
            markata clean --quiet
            ```
            """
            _clean(markata=markata, quiet=quiet, dry_run=dry_run)
    ```
    ]]></content>
  </entry>
  <entry>
    <title>jinja_md.py</title>

    <id>https://markata.dev/markata/plugins/jinja-md/</id>
    <link href="https://markata.dev/markata/plugins/jinja-md/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin enables Jinja2 templating within your markdown content. This allows you to dynamically generate content using Python expressions and access to the…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.jinja_md` plugin enables Jinja2 templating within your markdown
content. This allows you to dynamically generate content using Python expressions and
access to the full Markata context.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.jinja_md",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.jinja_md",
]
```

## Configuration

Configure Jinja markdown settings in your `markata.toml`:

```toml
[markata.jinja_md]
# List of files to ignore for Jinja processing
ignore = [
    "README.md",
    "CHANGELOG.md"
]
```

## Functionality

## Template Variables

Your markdown has access to:
- `post`: The current post being rendered
- `markata`: The Markata instance with all configuration and posts

## Example Usage

### Access Post Metadata
```markdown
# {{ post.title }}
{{ post.description }}

Published on: {{ post.date.strftime('%Y-%m-%d') }}
```

### Generate Link Lists
```markdown
{# One-liner list of all posts #}
{{ '\n'.join(markata.map('f"* [{title}]({slug})"', sort='slug')) }}

{# For-loop with filtering #}
{% for post in markata.map('post', filter='"git" in tags') %}
* [{{ post.title }}]({{ post.slug }})
{% endfor %}
```

### Include Raw Files
```markdown
{# Include file contents without processing #}
{% include_raw 'code/example.py' %}
```

## Jinja Extensions

The plugin supports:
1. Custom extensions via entrypoints
2. Built-in extensions like include_raw
3. Silent undefined variables
4. Custom error messages

## Error Handling

The plugin provides:
- Custom error messages for template syntax errors
- Silent handling of undefined variables
- Detailed error reporting with file and line info

## Dependencies

This plugin depends on:
- Jinja2 for template processing
- The `render_markdown` plugin for final HTML rendering

---

!!! function
    <h2 id="register_jinja_extensions" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">register_jinja_extensions <em class="small">function</em></h2>

    Gets jinja extensions from entrypoints and loads them in.

    Returns: List of jinja Extensions

???+ source "register_jinja_extensions <em class='small'>source</em>"
    ```python
    def register_jinja_extensions(config: dict) -> List[Extension]:
        """
        Gets jinja extensions from entrypoints and loads them in.

        Returns: List of jinja Extensions
        """

        import pkg_resources

        return [
            ep.load() for ep in pkg_resources.iter_entry_points(group="markata.jinja_md")
        ]
    ```
!!! class
    <h2 id="_SilentUndefined" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">_SilentUndefined <em class="small">class</em></h2>

    silence undefined variable errors in jinja templates.

    # Example
    ```python
    template = '{{ variable }}'
    post.content = Template( template, undefined=_SilentUndefined).render()
    ```

???+ source "_SilentUndefined <em class='small'>source</em>"
    ```python
    class _SilentUndefined(Undefined):
        """
        silence undefined variable errors in jinja templates.

        # Example
        ```python
        template = '{{ variable }}'
        post.content = Template( template, undefined=_SilentUndefined).render()
        ```
        """

        def _fail_with_undefined_error(self, *args, **kwargs):
            return ""
    ```
!!! class
    <h2 id="PostTemplateSyntaxError" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">PostTemplateSyntaxError <em class="small">class</em></h2>

    Custom error message for post template syntax errors.

???+ source "PostTemplateSyntaxError <em class='small'>source</em>"
    ```python
    class PostTemplateSyntaxError(TemplateSyntaxError):
        """
        Custom error message for post template syntax errors.
        """
    ```
!!! function
    <h2 id="pre_render" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">pre_render <em class="small">function</em></h2>

    jinja_md hook for markata to render your markdown post as a jinja template.

    The post itself is exposed as `post`, and the markata instance is exposed
    as `markata`.

???+ source "pre_render <em class='small'>source</em>"
    ```python
    def pre_render(markata: "Markata") -> None:
        """
        jinja_md hook for markata to render your markdown post as a jinja template.

        The post itself is exposed as `post`, and the markata instance is exposed
        as `markata`.
        """

        config = markata.config.jinja_md
        ignore_spec = pathspec.PathSpec.from_lines("gitwildmatch", config.ignore)
        # for post in markata.iter_articles(description="jinja_md"):

        # jinja_env = jinja2.Environment(
        #     extensions=[IncludeRawExtension, *register_jinja_extensions(config)],
        # )
        jinja_env = markata.jinja_env
        jinja_env.undefined = _SilentUndefined

        for post in markata.filter("jinja==True"):
            if post.get("jinja", True) and not ignore_spec.match_file(post["path"]):
                try:
                    # Include post metadata and markata version in cache key
                    # since these affect the rendered output
                    key = markata.make_hash(
                        "jinja_md",
                        "pre_render",
                        post.content,
                        str(post.to_dict()),  # Include all post metadata
                        __version__,  # Include markata version
                    )
                    content_from_cache = markata.precache.get(key)
                    if content_from_cache is None and post.content is not None:
                        post.content = jinja_env.from_string(post.content).render(
                            __version__=__version__,
                            markata=markata,
                            body=post.article_html,
                            config=markata.config,
                            post=post,
                        )
                        with markata.cache:
                            markata.cache.set(key, post.content)
                    else:
                        post.content = content_from_cache
                    # prevent double rendering
                    post.jinja = False
                except TemplateSyntaxError as e:
                    errorline = post.content.split("\n")[e.lineno - 1]
                    msg = f"""
                    Error while processing post {post["path"]}

                    {errorline}
                    """

                    raise PostTemplateSyntaxError(msg, lineno=e.lineno)
                except UndefinedError as e:
                    raise UndefinedError(f"{e} in {post['path']}")
    ```
    ]]></content>
  </entry>
  <entry>
    <title>datetime.py</title>

    <id>https://markata.dev/markata/plugins/datetime/</id>
    <link href="https://markata.dev/markata/plugins/datetime/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin handles date and time parsing for posts. It ensures consistent datetime handling by converting various date formats to timezone-aware datetime…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.datetime` plugin handles date and time parsing for posts. It ensures
consistent datetime handling by converting various date formats to timezone-aware datetime
objects.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.datetime",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.datetime",
]
```

Note: Disabling this plugin will prevent proper date handling and sorting in other plugins.

## Configuration

This plugin requires no explicit configuration. It processes dates from post frontmatter.

## Frontmatter Usage

Specify dates in your post frontmatter:

```markdown
---
title: My Post
date: 2024-01-28  # Date only
---
```

```markdown
---
title: My Post
date: 2024-01-28T12:00:00Z  # Date and time with timezone
---
```

## Functionality

## Date Parsing

The plugin supports:
- ISO format dates (2024-01-28)
- ISO format datetimes (2024-01-28T12:00:00Z)
- Natural language dates ("January 28, 2024")
- Date objects from Python
- Datetime objects with or without timezone

## Date Normalization

All dates are normalized to:
- Timezone-aware datetime objects
- UTC timezone if none specified
- Start of day (00:00:00) for date-only values

## Registered Attributes

The plugin modifies:
- `date`: Converted to timezone-aware datetime object

## Dependencies

This plugin depends on:
- python-dateutil for flexible date parsing
- pytz for timezone handling

---
    ]]></content>
  </entry>
  <entry>
    <title>manifest.py</title>

    <id>https://markata.dev/markata/plugins/manifest/</id>
    <link href="https://markata.dev/markata/plugins/manifest/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin generates a Web App Manifest (manifest.json) file for your site. This enables Progressive Web App (PWA) features and provides metadata for mobile…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.manifest` plugin generates a Web App Manifest (manifest.json) file
for your site. This enables Progressive Web App (PWA) features and provides metadata
for mobile devices.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.manifest",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.manifest",
]
```

## Configuration

Configure manifest settings in your `markata.toml`:

```toml
[markata]
# Site information
site_name = "My Blog"              # Full site name
short_name = "Blog"                # Short name for app icon
start_url = "/"                    # Starting URL when launched
display = "standalone"             # Display mode (standalone/fullscreen/etc)
background_color = "#ffffff"       # App background color
theme_color = "#4a9eff"           # Theme color for browser UI
description = "My awesome blog"    # Site description

# Output directory for manifest.json
output_dir = "markout"
```

## Functionality

## Manifest Generation

The plugin:
1. Collects site configuration
2. Integrates icon information from icon_resize plugin
3. Generates a standards-compliant manifest.json
4. Places it in the output directory

## Generated Output

Creates a manifest.json file with:
```json
{
    "name": "My Blog",
    "short_name": "Blog",
    "start_url": "/",
    "display": "standalone",
    "background_color": "#ffffff",
    "theme_color": "#4a9eff",
    "description": "My awesome blog",
    "icons": [
        {
            "src": "/favicon-192x192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        // ... other icon sizes
    ]
}
```

## Integration

Works with:
- icon_resize plugin for PWA icons
- service_worker plugin for offline support
- HTML templates for manifest linking

## Dependencies

This plugin works best with:
- The `icon_resize` plugin for PWA icons
- The `service_worker` plugin for full PWA support

---
    ]]></content>
  </entry>
  <entry>
    <title>subroute.py</title>

    <id>https://markata.dev/markata/plugins/subroute/</id>
    <link href="https://markata.dev/markata/plugins/subroute/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
None
    ]]></summary>

    <content type="html"><![CDATA[
---

None

---
    ]]></content>
  </entry>
  <entry>
    <title>prevnext.py</title>

    <id>https://markata.dev/markata/plugins/prevnext/</id>
    <link href="https://markata.dev/markata/plugins/prevnext/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin adds previous and next navigation links to each post, allowing readers to easily navigate between related content. Installation This plugin is…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.prevnext` plugin adds previous and next navigation links to each
post, allowing readers to easily navigate between related content.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.prevnext",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.prevnext",
]
```

## Configuration

Configure navigation behavior in `markata.toml`:

```toml
[markata.prevnext]
# Strategy for finding prev/next posts
# 'first': Use first map where post is found
# 'all': Use all maps
strategy = 'first'

# Custom colors (optional)
prevnext_color_text = "white"
prevnext_color_text_light = "black"
prevnext_color_angle = "white"
prevnext_color_angle_light = "black"

# Navigation maps
[[markata.prevnext.maps]]
# Map posts by category
category = "tutorials"
filter = "post.category == 'tutorials'"
sort = "post.date"
reverse = true

[[markata.prevnext.maps]]
# Map posts by series
category = "python-series"
filter = "post.series == 'python'"
sort = "post.part"
reverse = false
```

## Functionality

## Navigation Maps

The plugin allows you to:
1. Define multiple navigation maps
2. Filter posts by attributes
3. Sort posts by any field
4. Control sort direction
5. Group related content

## Navigation Strategies

Two navigation modes:
- `first`: Use first map containing the post
- `all`: Use all maps containing the post

## Template Integration

Adds to each post:
- Previous post link
- Next post link
- Navigation styling
- Responsive design

## Styling

Customizable colors:
- Text colors
- Arrow colors
- Light/dark mode support
- Hover effects

## Dependencies

This plugin depends on:
- jinja2 for templating
- pydantic for configuration

---

!!! class
    <h2 id="UnsupportedPrevNextStrategy" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">UnsupportedPrevNextStrategy <em class="small">class</em></h2>

    A custom error class to raise when an unsupporte prevnext strategy is
    defined.

???+ source "UnsupportedPrevNextStrategy <em class='small'>source</em>"
    ```python
    class UnsupportedPrevNextStrategy(NotImplementedError):
        """
        A custom error class to raise when an unsupporte prevnext strategy is
        defined.
        """
    ```
    ]]></content>
  </entry>
  <entry>
    <title>jinja_env.py</title>

    <id>https://markata.dev/markata/plugins/jinja-env/</id>
    <link href="https://markata.dev/markata/plugins/jinja-env/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
Jinja2 Environment Plugin Provides a centralized Jinja2 environment configuration for consistent template rendering across all Markata plugins. This plugin…
    ]]></summary>

    <content type="html"><![CDATA[
---

Jinja2 Environment Plugin

Provides a centralized Jinja2 environment configuration for consistent template rendering
across all Markata plugins. This plugin ensures template rendering behavior is consistent
and available even when specific template-using plugins are not enabled.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

``` toml
hooks = [
    "markata.plugins.jinja_env",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

``` toml
disabled_hooks = [
    "markata.plugins.jinja_env",
]
```

## Configuration

Configure Jinja environment settings in your `markata.toml`:

``` toml
[markata.jinja_env]
template_paths = ["templates"]  # Additional template paths to search
undefined_silent = true        # Return empty string for undefined variables
trim_blocks = true            # Remove first newline after block
lstrip_blocks = true          # Strip tabs/spaces from start of line
template_cache_dir = ".markata.cache/template_bytecode"
```

# Usage

The environment is automatically available to other plugins via `markata.config.jinja_env`.
Template loading follows this order:
1. Package templates (built-in Markata templates)
2. User template paths (configured via template_paths)

Example usage in a plugin:

``` python
def render_template(markata, content):
    template = markata.jinja_env.from_string(content)
    return template.render(markata=markata)
```

# Notes

- Template paths are resolved relative to the current working directory
- Package templates are always available and take precedence
- Silent undefined behavior means undefined variables render as empty strings

---

!!! class
    <h2 id="_SilentUndefined" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">_SilentUndefined <em class="small">class</em></h2>

    Custom undefined type that returns empty string for undefined variables.

???+ source "_SilentUndefined <em class='small'>source</em>"
    ```python
    class _SilentUndefined(jinja2.Undefined):
        """Custom undefined type that returns empty string for undefined variables."""

        def _fail_with_undefined_error(self, *args, **kwargs):
            return ""

        __add__ = __radd__ = __mul__ = __rmul__ = __div__ = __rdiv__ = __truediv__ = (
            __rtruediv__
        ) = __floordiv__ = __rfloordiv__ = __mod__ = __rmod__ = __pos__ = __neg__ = (
            __call__
        ) = __getitem__ = __lt__ = __le__ = __gt__ = __ge__ = __int__ = __float__ = (
            __complex__
        ) = __pow__ = __rpow__ = _fail_with_undefined_error
    ```
!!! class
    <h2 id="MarkataTemplateCache" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">MarkataTemplateCache <em class="small">class</em></h2>

    Template bytecode cache for improved performance.

???+ source "MarkataTemplateCache <em class='small'>source</em>"
    ```python
    class MarkataTemplateCache(jinja2.BytecodeCache):
        """Template bytecode cache for improved performance."""

        def __init__(self, directory):
            self.directory = Path(directory)
            self.directory.mkdir(parents=True, exist_ok=True)

        def load_bytecode(self, bucket):
            filename = self.directory / f"{bucket.key}.cache"
            if filename.exists():
                with open(filename, "rb") as f:
                    bucket.bytecode_from_string(f.read())

        def dump_bytecode(self, bucket):
            filename = self.directory / f"{bucket.key}.cache"
            with open(filename, "wb") as f:
                f.write(bucket.bytecode_to_string())
    ```
!!! class
    <h2 id="JinjaEnvConfig" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">JinjaEnvConfig <em class="small">class</em></h2>

    Configuration for the Jinja environment.

???+ source "JinjaEnvConfig <em class='small'>source</em>"
    ```python
    class JinjaEnvConfig(pydantic.BaseModel):
        """Configuration for the Jinja environment."""

        templates_dir: List[str] = []
        undefined_silent: bool = True
        trim_blocks: bool = True
        lstrip_blocks: bool = True
        template_cache_dir: Path = Path(".markata.cache/template_bytecode")

        model_config = pydantic.ConfigDict(
            validate_assignment=True,  # Config model
            arbitrary_types_allowed=True,
            extra="allow",
            str_strip_whitespace=True,
            validate_default=True,
            coerce_numbers_to_str=True,
            populate_by_name=True,
        )
    ```
!!! function
    <h2 id="config_model" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">config_model <em class="small">function</em></h2>

    Register configuration models.

???+ source "config_model <em class='small'>source</em>"
    ```python
    def config_model(markata: "Markata") -> None:
        """Register configuration models."""
        markata.config_models.append(JinjaEnvConfig)
    ```
!!! function
    <h2 id="configure" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">configure <em class="small">function</em></h2>

    Initialize and configure the Jinja2 environment for Markata.

    This hook runs early in the configuration stage to ensure the jinja environment
    is available for other plugins that need it during configuration.

    Args:
        markata: The Markata instance

???+ source "configure <em class='small'>source</em>"
    ```python
    def configure(markata: Markata) -> None:
        """Initialize and configure the Jinja2 environment for Markata.

        This hook runs early in the configuration stage to ensure the jinja environment
        is available for other plugins that need it during configuration.

        Args:
            markata: The Markata instance
        """
        # Get configuration, falling back to defaults
        config = JinjaEnvConfig()
        if hasattr(markata.config, "jinja_env"):
            if isinstance(markata.config.jinja_env, dict):
                config = JinjaEnvConfig(**markata.config.jinja_env)

        # TODO: setting up env twice could not get dynamic templates to be recognized on first pass
        loaders = []
        if markata.config.templates_dir:
            for path in markata.config.templates_dir:
                path = Path(path).expanduser().resolve()
                if path.exists():
                    loaders.append(FileSystemLoader(str(path)))
        # Create environment
        env_for_dynamic_render = Environment(
            loader=ChoiceLoader(loaders),
            undefined=_SilentUndefined if config.undefined_silent else jinja2.Undefined,
            trim_blocks=config.trim_blocks,
            lstrip_blocks=config.lstrip_blocks,
            bytecode_cache=MarkataTemplateCache(config.template_cache_dir),
            auto_reload=True,
        )

        markata.config.dynamic_templates_dir.mkdir(parents=True, exist_ok=True)
        head_template = markata.config.dynamic_templates_dir / "head.html"
        new_content = env_for_dynamic_render.get_template("dynamic_head.html").render(
            {"markata": markata}
        )
        current_content = head_template.read_text() if head_template.exists() else ""
        if current_content != new_content:
            head_template.write_text(new_content)

        # Set up loaders
        loaders = []

        # Add package templates first (lowest priority)
        # loaders.append(PackageLoader("markata", "templates"))

        # Add user template paths (medium priority)
        if markata.config.templates_dir:
            for path in markata.config.templates_dir:
                path = Path(path).expanduser().resolve()
                if path.exists():
                    loaders.append(FileSystemLoader(str(path)))

        # Add dynamic templates directory (highest priority)
        # dynamic_templates_dir = Path(".markata.cache/templates")
        # dynamic_templates_dir.mkdir(parents=True, exist_ok=True)
        # loaders.append(FileSystemLoader(str(dynamic_templates_dir)))

        # Create environment
        env = Environment(
            loader=ChoiceLoader(loaders),
            undefined=_SilentUndefined if config.undefined_silent else jinja2.Undefined,
            trim_blocks=config.trim_blocks,
            lstrip_blocks=config.lstrip_blocks,
            bytecode_cache=MarkataTemplateCache(config.template_cache_dir),
            auto_reload=True,
        )

        # Register the environment on the config's private attribute
        markata.jinja_env = env
    ```
!!! function
    <h2 id="get_template_paths" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">get_template_paths <em class="small">function</em></h2>

    Extract template paths from Jinja2 Environment's loader.

    Args:
        env: Jinja2 Environment instance

    Returns:
        List of template directory paths from all FileSystemLoaders

???+ source "get_template_paths <em class='small'>source</em>"
    ```python
    def get_template_paths(env: Environment) -> list[str]:
        """Extract template paths from Jinja2 Environment's loader.

        Args:
            env: Jinja2 Environment instance

        Returns:
            List of template directory paths from all FileSystemLoaders
        """
        paths = []
        loader = env.loader

        if isinstance(loader, ChoiceLoader):
            for sub_loader in loader.loaders:
                if isinstance(sub_loader, FileSystemLoader):
                    paths.extend(sub_loader.searchpath)
        elif isinstance(loader, FileSystemLoader):
            paths.extend(loader.searchpath)

        return paths
    ```
!!! function
    <h2 id="get_templates_mtime" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">get_templates_mtime <em class="small">function</em></h2>

    Get latest mtime from all template directories.

    This tracks changes to any template file including includes, extends, and imports.

    Args:
        env: Jinja2 Environment instance

    Returns:
        Maximum modification time across all template files, or 0 if none found

???+ source "get_templates_mtime <em class='small'>source</em>"
    ```python
    def get_templates_mtime(env: Environment) -> float:
        """Get latest mtime from all template directories.

        This tracks changes to any template file including includes, extends, and imports.

        Args:
            env: Jinja2 Environment instance

        Returns:
            Maximum modification time across all template files, or 0 if none found
        """
        max_mtime = 0
        for template_dir in get_template_paths(env):
            template_path = Path(template_dir)
            if template_path.exists():
                for path in template_path.rglob('*'):
                    if path.is_file():
                        try:
                            max_mtime = max(max_mtime, path.stat().st_mtime)
                        except (OSError, FileNotFoundError):
                            continue
        return max_mtime
    ```
!!! function
    <h2 id="get_template" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">get_template <em class="small">function</em></h2>

    Get a template with fallback handling and caching.

    Tries to load the template in the following order:
    1. From the Jinja2 environment (template loader)
    2. As a file path (if the string is a valid file path)
    3. As a string template (direct template compilation)

    Templates are cached after loading for performance.

    Args:
        env: Jinja2 Environment instance
        template: Template name, file path, or template string

    Returns:
        Compiled Jinja2 Template object

???+ source "get_template <em class='small'>source</em>"
    ```python
    def get_template(env: Environment, template: str) -> jinja2.Template:
        """Get a template with fallback handling and caching.

        Tries to load the template in the following order:
        1. From the Jinja2 environment (template loader)
        2. As a file path (if the string is a valid file path)
        3. As a string template (direct template compilation)

        Templates are cached after loading for performance.

        Args:
            env: Jinja2 Environment instance
            template: Template name, file path, or template string

        Returns:
            Compiled Jinja2 Template object
        """
        # Try to load from environment first
        try:
            return env.get_template(template)
        except jinja2.TemplateNotFound:
            pass

        # Try to load as a file
        try:
            template_content = Path(template).read_text()
            return env.from_string(template_content)
        except FileNotFoundError:
            pass
        except OSError:  # File name too long, etc.
            pass

        # Fall back to treating it as a string template
        return env.from_string(template)
    ```
    ]]></content>
  </entry>
  <entry>
    <title>flat_slug.py</title>

    <id>https://markata.dev/markata/plugins/flat-slug/</id>
    <link href="https://markata.dev/markata/plugins/flat-slug/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin handles URL slug generation for your articles. It sanitizes special characters that don't work in browsers and provides a consistent URL structure.…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.flat_slug` plugin handles URL slug generation for your articles.
It sanitizes special characters that don't work in browsers and provides a consistent
URL structure.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.flat_slug",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.flat_slug",
]
```

Note: Disabling this plugin will prevent automatic URL slug generation and sanitization.

## Configuration

Configure the plugin behavior in your `markata.toml`:

```toml
[markata.flat_slug]
slugify = true  # Set to false to disable automatic slug sanitization
```

## Functionality

## Explicit Slug in Frontmatter

If you explicitly set the slug in the frontmatter of a post, markata will not
overwrite it:

```markdown
---
title: My First Post
slug: /my-post
---

This is my first post it will be at `<markata.config.url>/my-post/`
regardless of filename.
```

## Automatic Slug Based on Filename

By default the flat_slug plugin will use the `stem` of your filename (filename without
extension) unless you explicitly set your slug in frontmatter.

Examples:
* `/pages/my-post.md` becomes `<markata.config.url>/my-post/`
* `/pages/blog/a-blog-post.md` becomes `<markata.config.url>/a-blog-post/`

## Registered Attributes

The plugin registers the following attributes on Post objects:
- `should_slugify`: Boolean indicating if the post's slug should be sanitized

---

!!! function
    <h2 id="pre_render" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">pre_render <em class="small">function</em></h2>

    Sets the article slug if one is not already set in the frontmatter.

???+ source "pre_render <em class='small'>source</em>"
    ```python
    def pre_render(markata: "Markata") -> None:
        """
        Sets the article slug if one is not already set in the frontmatter.
        """
        from slugify import slugify

        for article in markata.iter_articles(description="creating slugs"):
            stem = article.get(
                "slug",
                Path(article.get("path", article.get("title", ""))).stem,
            )
            if article.should_slugify:
                article.slug = "/".join([slugify(s) for s in stem.split("/")])
            else:
                article.slug = stem
    ```
    ]]></content>
  </entry>
  <entry>
    <title>redirects.py</title>

    <id>https://markata.dev/markata/plugins/redirects/</id>
    <link href="https://markata.dev/markata/plugins/redirects/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin creates static redirects for your site using a simple configuration file. Compatible with services like Cloudflare Pages and Netlify. Installation…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.redirects` plugin creates static redirects for your site using
a simple configuration file. Compatible with services like Cloudflare Pages and Netlify.

## Installation

This plugin is built-in but not enabled by default. Add it to your plugins list:

```toml
hooks = [
    "markata.plugins.redirects",
]
```

## Uninstallation

Remove the plugin from your hooks list in `markata.toml`:

```toml
hooks = [
    # Remove or comment out the line below
    # "markata.plugins.redirects",
]
```

## Configuration

Configure redirects in `markata.toml`:

```toml
[markata]
# Default redirects file location
redirects = "static/_redirects"

# Or use assets_dir to set default location
assets_dir = "static"
```

## Redirects File Format

Create a `_redirects` file with entries:

```text
# Basic redirect
/old-path    /new-path

# Force specific status code
/api/*    /v2/api/:splat    301

# Redirect with query parameters
/search    /new-search    301?q=:q

# Proxy to external URL
/external    https://api.example.com    200

# Redirect based on country
/app/*    /app/us/:splat    200    Country=us
/app/*    /app/mx/:splat    200    Country=mx

# Redirect with placeholders
/blog/:year/:month    /posts/:year/:month
```

## Functionality

## Redirect Types

Supports:
- Basic redirects
- Path patterns
- Query parameters
- Status codes
- Country rules
- Placeholders

## File Generation

The plugin:
1. Reads redirect rules
2. Creates HTML files
3. Handles directories
4. Preserves parameters

## Compatibility

Works with:
- Cloudflare Pages
- Netlify
- Static hosting
- Local development

## Performance

Features:
- Efficient file creation
- Pattern matching
- Rule validation
- Error handling

## Dependencies

This plugin depends on:
- pydantic for configuration
- pathlib for file operations

---

!!! class
    <h2 id="Redirect" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">Redirect <em class="small">class</em></h2>

    DataClass to store the original and new url

???+ source "Redirect <em class='small'>source</em>"
    ```python
    class Redirect(pydantic.BaseModel):
        "DataClass to store the original and new url"

        original: str
        new: str
        markata: Markata
        model_config = pydantic.ConfigDict(
            validate_assignment=True, arbitrary_types_allowed=True
        )
    ```
!!! function
    <h2 id="save" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">save <em class="small">function</em></h2>

    saves an index.html in the directory called out by the redirect.

???+ source "save <em class='small'>source</em>"
    ```python
    def save(markata: "Markata") -> None:
        """
        saves an index.html in the directory called out by the redirect.
        """
        redirects_file = Path(markata.config.redirects.redirects_file)
        if redirects_file.exists():
            raw_redirects = redirects_file.read_text().split("\n")
        else:
            raw_redirects = []

        redirects = [
            Redirect(original=s[0], new=s[1], markata=markata)
            for r in raw_redirects
            if "*" not in r and len(s := r.split()) == 2 and not r.strip().startswith("#")
        ]

        if "redirect_template" in markata.config:
            template_file = Path(str(markata.config.get("redirect_template")))
        else:
            template_file = DEFAULT_REDIRECT_TEMPLATE

        # Get template mtime to bust cache when template changes
        template_mtime = template_file.stat().st_mtime if template_file.exists() else 0

        key = markata.make_hash("redirects", "raw_redirects", raw_redirects, str(template_mtime))
        with markata.cache as cache:
            cache.get(key)
            if cache.get(key) == "done":
                return

            cache.set(key, "done", expire=markata.config.default_cache_expire)

        template = Template(template_file.read_text())

        for redirect in redirects:
            file = markata.config.output_dir / redirect.original.strip("/") / "index.html"
            file.parent.mkdir(parents=True, exist_ok=True)
            new_content = template.render(redirect.dict(), config=markata.config)
            current_content = file.read_text() if file.exists() else ""
            if current_content != new_content:
                file.write_text(new_content)
    ```
    ]]></content>
  </entry>
  <entry>
    <title>generator.py</title>

    <id>https://markata.dev/markata/plugins/generator/</id>
    <link href="https://markata.dev/markata/plugins/generator/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin adds a meta generator tag to each generated HTML page, indicating that the page was generated by Markata and including the version number.…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.generator` plugin adds a meta generator tag to each generated HTML page,
indicating that the page was generated by Markata and including the version number.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.generator",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.generator",
]
```

## Configuration

The plugin uses the global `prettify_html` configuration:

```toml
[markata]
prettify_html = true  # Set to false to disable HTML prettification
```

## Functionality

## Meta Tag Generation

The plugin adds a meta tag to the head of each HTML document:
```html
<meta name="generator" content="markata X.Y.Z">
```
where X.Y.Z is the current Markata version.

## Dependencies

This plugin depends on:
- The `render_markdown` plugin to provide HTML content

---
    ]]></content>
  </entry>
  <entry>
    <title>analytics.py</title>

    <id>https://markata.dev/markata/plugins/analytics/</id>
    <link href="https://markata.dev/markata/plugins/analytics/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin generates analytics and contribution visualizations for your Markata site. It creates a contributions heatmap similar to GitHub's contribution…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.analytics` plugin generates analytics and contribution visualizations
for your Markata site. It creates a contributions heatmap similar to GitHub's contribution
graph and provides post statistics.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.analytics",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.analytics",
]
```

## Configuration

Configure analytics behavior in your `markata.toml`:

```toml
[markata.analytics]
# Maximum scale for contribution heatmap
contributions_max_post_scale = 5

# Color map for the heatmap (any matplotlib colormap)
contributions_cmap = "rocket"

# Filter to apply when generating analytics
filter = ""  # e.g. "draft != True" to exclude drafts
```

## Functionality

## Contribution Heatmap

Generates a heatmap visualization showing:
- Post frequency over time
- Relative activity levels using configurable color scales
- Year-over-year contribution patterns

## Post Statistics

Provides analytics including:
- Total number of posts
- Posts per month/year
- Word count statistics
- Reading time estimates

## Output Files

The plugin generates these files in your output directory:
- `contributions.svg`: The contribution heatmap
- `analytics.json`: Raw analytics data

## Dependencies

This plugin depends on:
- matplotlib (for heatmap generation)
- The `datetime` plugin for post date information

---
    ]]></content>
  </entry>
  <entry>
    <title>post_model.py</title>

    <id>https://markata.dev/markata/plugins/post-model/</id>
    <link href="https://markata.dev/markata/plugins/post-model/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin defines the core Post model used throughout Markata. It provides robust validation, serialization, and configuration options for all post…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.post_model` plugin defines the core Post model used throughout
Markata. It provides robust validation, serialization, and configuration options for
all post attributes.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.post_model",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.post_model",
]
```

Note: Disabling this plugin will break most of Markata's functionality as the Post
model is fundamental to the system.

## Configuration

Configure post model behavior in your `markata.toml`:

```toml
[markata.post_model]
# Attributes to include when serializing posts
include = [
    "date",
    "description",
    "published",
    "slug",
    "title",
    "content",
    "html"
]

# Attributes to show in post representations
repr_include = [
    "date",
    "description",
    "published",
    "slug",
    "title"
]

# Attributes to include when exporting
export_include = [
    "date",
    "description",
    "published",
    "slug",
    "title"
]
```

## Functionality

## Post Model

Core attributes:
- `path`: Path to source file
- `slug`: URL-friendly identifier
- `href`: Full URL path
- `published`: Publication status
- `description`: Post summary
- `content`: Raw markdown content
- `html`: Rendered HTML content
- `tags`: List of post tags
- `date`: Publication date
- `title`: Post title

## Validation

The model provides:
- Type checking and coercion
- Required field validation
- Custom field validators
- Default values
- Rich error messages

## Serialization

Supports multiple output formats:
- Full serialization (all fields)
- Representation (subset for display)
- Export (subset for external use)
- JSON/YAML compatible

## Performance

Uses optimized Pydantic config:
- Disabled assignment validation
- Arbitrary types allowed
- Extra fields allowed
- String whitespace stripping
- Default value validation
- Number to string coercion
- Alias population

## Dependencies

This plugin depends on:
- pydantic for model definition
- rich for console output
- yaml for YAML handling

---

!!! class
    <h2 id="PostModelConfig" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">PostModelConfig <em class="small">class</em></h2>

    Configuration for the Post model

???+ source "PostModelConfig <em class='small'>source</em>"
    ```python
    class PostModelConfig(pydantic.BaseModel):
        """Configuration for the Post model"""

        def __init__(self, **data) -> None:
            """

            include: post attributes to include by default in Post
            model serialization.
            repr_include: post attributes to include by default in Post
            repr.  If `repr_include` is None, it will default to
            `include`, but it is likely that you want less in the repr
            than serialized output.

            example:

            ``` toml title='markata.toml'
            [markata.post_model]
            include = ['date', 'description', 'published',
                'slug', 'title', 'content', 'html']
            repr_include = ['date', 'description', 'published', 'slug', 'title']
            ```
            """
            super().__init__(**data)

        default_date: datetime.date = datetime.date.today()
        include: List[str] = [
            "date",
            "description",
            "published",
            "slug",
            "title",
            "content",
            "html",
        ]
        repr_include: Optional[List[str]] = [
            "date",
            "description",
            "published",
            "slug",
            "title",
        ]
        export_include: Optional[List[str]] = [
            "date",
            "description",
            "published",
            "slug",
            "title",
        ]

        model_config = ConfigDict(
            validate_assignment=True,  # Config model
            arbitrary_types_allowed=True,
            extra="allow",
            str_strip_whitespace=True,
            validate_default=True,
            coerce_numbers_to_str=True,
            populate_by_name=True,
        )

        @field_validator("repr_include", mode="before")
        @classmethod
        def repr_include_validator(cls, v, info) -> Optional[List[str]]:
            if v:
                return v
            return info.data.get("include")
    ```
!!! method
    <h2 id="metadata" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">metadata <em class="small">method</em></h2>

    for backwards compatability

???+ source "metadata <em class='small'>source</em>"
    ```python
    def metadata(self: "Post") -> Dict:
            "for backwards compatability"
            return self.__dict__
    ```
!!! method
    <h2 id="to_dict" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">to_dict <em class="small">method</em></h2>

    for backwards compatability

???+ source "to_dict <em class='small'>source</em>"
    ```python
    def to_dict(self: "Post") -> Dict:
            "for backwards compatability"
            return self.__dict__
    ```
!!! method
    <h2 id="__getitem__" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">__getitem__ <em class="small">method</em></h2>

    for backwards compatability

???+ source "__getitem__ <em class='small'>source</em>"
    ```python
    def __getitem__(self: "Post", item: str) -> Any:
            "for backwards compatability"
            return getattr(self, item)
    ```
!!! method
    <h2 id="__setitem__" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">__setitem__ <em class="small">method</em></h2>

    for backwards compatability

???+ source "__setitem__ <em class='small'>source</em>"
    ```python
    def __setitem__(self: "Post", key: str, item: Any) -> None:
            "for backwards compatability"
            setattr(self, key, item)
    ```
!!! method
    <h2 id="get" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">get <em class="small">method</em></h2>

    for backwards compatability

???+ source "get <em class='small'>source</em>"
    ```python
    def get(self: "Post", item: str, default: Any) -> Any:
            "for backwards compatability"
            return getattr(self, item, default)
    ```
!!! method
    <h2 id="keys" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">keys <em class="small">method</em></h2>

    for backwards compatability

???+ source "keys <em class='small'>source</em>"
    ```python
    def keys(self: "Post") -> List[str]:
            "for backwards compatability"
            return self.__dict__.keys()
    ```
!!! method
    <h2 id="yaml" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">yaml <em class="small">method</em></h2>

    dump model to yaml

???+ source "yaml <em class='small'>source</em>"
    ```python
    def yaml(self: "Post") -> str:
            """
            dump model to yaml
            """
            import yaml

            return yaml.dump(
                self.dict(
                    include={i: True for i in self.markata.config.post_model.include}
                ),
                Dumper=yaml.CDumper,
            )
    ```
!!! method
    <h2 id="markdown" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">markdown <em class="small">method</em></h2>

    dump model to markdown

???+ source "markdown <em class='small'>source</em>"
    ```python
    def markdown(self: "Post") -> str:
            """
            dump model to markdown
            """

            import yaml

            frontmatter = yaml.dump(
                self.dict(
                    include={
                        i: True
                        for i in [
                            _i
                            for _i in self.markata.config.post_model.include
                            if _i != "content"
                        ]
                    }
                ),
                Dumper=yaml.CDumper,
            )
            post = "---\n"
            post += frontmatter
            post += "---\n\n"

            if self.content:
                post += self.content
            return post
    ```
!!! method
    <h2 id="dumps" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">dumps <em class="small">method</em></h2>

    dumps raw article back out

???+ source "dumps <em class='small'>source</em>"
    ```python
    def dumps(self):
            """
            dumps raw article back out
            """
            return f"---\n{self.yaml()}\n\n---\n\n{self.content}"
    ```
!!! method
    <h2 id="parse_date_time" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">parse_date_time <em class="small">method</em></h2>

    Single validator to handle all date_time parsing cases

???+ source "parse_date_time <em class='small'>source</em>"
    ```python
    def parse_date_time(cls, v, info):
            """Single validator to handle all date_time parsing cases"""
            # If we have an explicit date_time value
            if v is not None:
                if isinstance(v, datetime.datetime):
                    return v
                if isinstance(v, datetime.date):
                    return datetime.datetime.combine(v, datetime.time.min)
                if isinstance(v, str):
                    try:
                        # Try ISO format first
                        return datetime.datetime.fromisoformat(v.replace("Z", "+00:00"))
                    except ValueError:
                        try:
                            return datetime.datetime.strptime(v, "%Y-%m-%d %H:%M")
                        except ValueError:
                            try:
                                return datetime.datetime.strptime(v, "%Y-%m-%d")
                            except ValueError:
                                # Try dateparser as last resort for explicit date_time
                                import dateparser

                                parsed = dateparser.parse(v)
                                if parsed:
                                    return parsed
                                return datetime.datetime.now()

            # Get the raw date string directly from raw_date field
            raw_date = info.data.get("raw_date")
            if raw_date and isinstance(raw_date, str):
                try:
                    # Try ISO format first
                    return datetime.datetime.fromisoformat(raw_date.replace("Z", "+00:00"))
                except ValueError:
                    try:
                        # Try parsing raw_date with time first
                        return datetime.datetime.strptime(raw_date, "%Y-%m-%d %H:%M")
                    except ValueError:
                        try:
                            # Fallback to date only
                            return datetime.datetime.strptime(raw_date, "%Y-%m-%d")
                        except ValueError:
                            # Try dateparser as last resort
                            import dateparser

                            parsed = dateparser.parse(raw_date)
                            if parsed:
                                return parsed

            # If no raw_date, try to derive from date field
            date = info.data.get("date")
            if date:
                if isinstance(date, datetime.datetime):
                    return date
                if isinstance(date, str):
                    try:
                        # Try ISO format first
                        return datetime.datetime.fromisoformat(date.replace("Z", "+00:00"))
                    except ValueError:
                        try:
                            # Try parsing date with time first
                            return datetime.datetime.strptime(date, "%Y-%m-%d %H:%M")
                        except ValueError:
                            try:
                                # Fallback to date only
                                return datetime.datetime.strptime(date, "%Y-%m-%d")
                            except ValueError:
                                # Try dateparser as last resort
                                import dateparser

                                parsed = dateparser.parse(date)
                                if parsed:
                                    return parsed
                if isinstance(date, datetime.date):
                    return datetime.datetime.combine(date, datetime.time.min)

            # If we still don't have a date, use now
            return datetime.datetime.now()
    ```
!!! method
    <h2 id="__init__" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">__init__ <em class="small">method</em></h2>

    include: post attributes to include by default in Post
    model serialization.
    repr_include: post attributes to include by default in Post
    repr.  If `repr_include` is None, it will default to
    `include`, but it is likely that you want less in the repr
    than serialized output.

    example:

    ``` toml title='markata.toml'
    [markata.post_model]
    include = ['date', 'description', 'published',
        'slug', 'title', 'content', 'html']
    repr_include = ['date', 'description', 'published', 'slug', 'title']
    ```

???+ source "__init__ <em class='small'>source</em>"
    ```python
    def __init__(self, **data) -> None:
            """

            include: post attributes to include by default in Post
            model serialization.
            repr_include: post attributes to include by default in Post
            repr.  If `repr_include` is None, it will default to
            `include`, but it is likely that you want less in the repr
            than serialized output.

            example:

            ``` toml title='markata.toml'
            [markata.post_model]
            include = ['date', 'description', 'published',
                'slug', 'title', 'content', 'html']
            repr_include = ['date', 'description', 'published', 'slug', 'title']
            ```
            """
            super().__init__(**data)
    ```
    ]]></content>
  </entry>
  <entry>
    <title>auto_title.py</title>

    <id>https://markata.dev/markata/plugins/auto-title/</id>
    <link href="https://markata.dev/markata/plugins/auto-title/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin automatically generates titles for posts that don't have a title specified in their frontmatter. It uses the filename to create a human-readable…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.auto_title` plugin automatically generates titles for posts that
don't have a title specified in their frontmatter. It uses the filename to create a
human-readable title.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.auto_title",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.auto_title",
]
```

## Configuration

This plugin requires no configuration. It automatically processes any post without a title.

## Functionality

## Title Generation

The plugin generates titles by:
1. Using the filename (without extension)
2. Replacing hyphens and underscores with spaces
3. Converting to title case

Examples:
- `my-first-post.md` becomes "My First Post"
- `python_tips_and_tricks.md` becomes "Python Tips And Tricks"

## Frontmatter Override

You can always override the automatic title by specifying one in frontmatter:

```markdown
---
title: My Custom Title
---
```

## Registered Attributes

The plugin modifies:
- `title`: Set to the generated title if none exists in frontmatter

---
    ]]></content>
  </entry>
  <entry>
    <title>didyoumean.py</title>

    <id>https://markata.dev/markata/plugins/didyoumean/</id>
    <link href="https://markata.dev/markata/plugins/didyoumean/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
DidYouMean Plugin for Markata Automatically generates redirect pages for URLs that may be mistyped by users. Installation Configuration Usage This plugin will…
    ]]></summary>

    <content type="html"><![CDATA[
---

DidYouMean Plugin for Markata

Automatically generates redirect pages for URLs that may be mistyped by users.

## Installation

```toml
hooks = [
    "markata.plugins.didyoumean",
]
```

## Configuration

```toml
[markata.didyoumean]
output_dir = "markout"  # Directory where HTML files will be saved
didyoumean_filter = "True"  # A filter expression to determine which pages should be included in suggestions
search_hotkey = "/"  # Hotkey to focus the search input. Set to None to disable. Default is "/"
```

# Usage

This plugin will generate HTML redirect pages for missing URLs that forward users
to the most relevant existing page, or present a list of suggested pages when ambiguity exists.

---

!!! function
    <h2 id="render_template" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">render_template <em class="small">function</em></h2>

    Render a template with the given context.

???+ source "render_template <em class='small'>source</em>"
    ```python
    def render_template(markata: "Markata", template_name: str, **context) -> str:
        """Render a template with the given context."""
        template = markata.jinja_env.get_template(template_name)
        return template.render(markata=markata, body="", config=markata.config, **context)
    ```
    ]]></content>
  </entry>
  <entry>
    <title>icon_resize.py</title>

    <id>https://markata.dev/markata/plugins/icon-resize/</id>
    <link href="https://markata.dev/markata/plugins/icon-resize/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin automatically generates favicons in multiple sizes from a single source image. This ensures your site has appropriate icons for different devices…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.icon_resize` plugin automatically generates favicons in multiple
sizes from a single source image. This ensures your site has appropriate icons for
different devices and platforms.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.icon_resize",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.icon_resize",
]
```

## Configuration

Configure icon settings in your `markata.toml`:

```toml
[markata]
# Directory for output files
output_dir = "markout"

# Directory containing static assets
assets_dir = "static"

# Path to source icon file
icon = "static/icon.png"

# Optional: List of icon sizes to generate
# Default sizes are provided if not specified
icon_sizes = [16, 32, 48, 128, 180, 192, 512]
```

## Functionality

## Icon Generation

The plugin:
1. Loads the source icon image
2. Resizes it to multiple standard sizes
3. Saves each size as a separate PNG file
4. Generates appropriate HTML meta tags

## Default Sizes

If not configured, generates these standard sizes:
- 16x16: Classic favicon size
- 32x32: Modern favicon size
- 48x48: Windows taskbar
- 128x128: Chrome Web Store
- 180x180: Apple Touch icon
- 192x192: Android homescreen
- 512x512: PWA splash screen

## Output Files

Generated files follow this pattern:
- `favicon-{size}x{size}.png`
- `favicon.ico` (16x16 and 32x32 combined)
- `apple-touch-icon.png` (180x180)

## HTML Integration

The plugin adds appropriate meta tags to your HTML:
```html
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
```

## Dependencies

This plugin depends on:
- Pillow (PIL) for image manipulation

---
    ]]></content>
  </entry>
  <entry>
    <title>copy_assets.py</title>

    <id>https://markata.dev/markata/plugins/copy-assets/</id>
    <link href="https://markata.dev/markata/plugins/copy-assets/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin copies static assets (images, CSS, JavaScript, etc.) from your assets directory to the output directory during the build process. Installation This…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.copy_assets` plugin copies static assets (images, CSS, JavaScript, etc.)
from your assets directory to the output directory during the build process.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.copy_assets",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.copy_assets",
]
```

## Configuration

Configure asset directories in your `markata.toml`:

```toml
[markata]
# Directory containing your static assets
assets_dir = "assets"

# Directory where assets will be copied
output_dir = "markout"
```

## Functionality

## Asset Copying

The plugin:
1. Checks if the configured assets directory exists
2. Recursively copies all files and directories from assets_dir to output_dir
3. Preserves directory structure
4. Updates existing files if they've changed
5. Maintains any existing files in the output directory

## Usage Example

Place static assets in your assets directory:
```
assets/
  ├── css/
  │   └── style.css
  ├── js/
  │   └── main.js
  └── images/
      └── logo.png
```

These will be copied to:
```
markout/
  ├── css/
  │   └── style.css
  ├── js/
  │   └── main.js
  └── images/
      └── logo.png
```

---
    ]]></content>
  </entry>
  <entry>
    <title>heading_link.py</title>

    <id>https://markata.dev/markata/plugins/heading-link/</id>
    <link href="https://markata.dev/markata/plugins/heading-link/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin adds clickable link icons next to headings in your HTML output. This makes it easy for readers to share direct links to specific sections of your…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.heading_link` plugin adds clickable link icons next to headings in
your HTML output. This makes it easy for readers to share direct links to specific
sections of your content.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.heading_link",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.heading_link",
]
```

## Configuration

This plugin requires no explicit configuration. It automatically processes all headings
in your HTML content.

## Functionality

## Link Generation

The plugin:
1. Finds all heading elements (h1-h6) in the HTML
2. Adds an SVG link icon next to each heading
3. Makes the icon clickable to copy the direct URL
4. Uses heading text to generate URL-safe anchor IDs

## HTML Output

For each heading, the plugin adds:
```html
<h2 id="my-heading">
    My Heading
    <a class="heading-link" href="#my-heading">
        <svg><!-- Link icon SVG --></svg>
    </a>
</h2>
```

## URL Structure

Generated URLs follow this pattern:
- Base URL: The page's URL
- Anchor: `#heading-text-as-slug`

Example:
- `https://example.com/post/#my-heading-section`

## Dependencies

This plugin depends on:
- BeautifulSoup4 for HTML parsing and modification
- The `render_markdown` plugin to provide HTML content

---

!!! function
    <h2 id="post_render" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">post_render <em class="small">function</em></h2>

    This plugin creates a link svg next to all headings.

???+ source "post_render <em class='small'>source</em>"
    ```python
    def post_render(markata: Markata) -> None:
        """
        This plugin creates a link svg next to all headings.
        """

        with markata.cache as cache:
            for article in markata.iter_articles("link headers"):
                key = markata.make_hash(
                    "heading_link",
                    "post_render",
                    __version__,
                    article.content,
                    article.html,
                )

                html_from_cache = markata.precache.get(key)

                if html_from_cache is not None:
                    article.html = html_from_cache
                    continue

                if isinstance(article.html, str):
                    article.html = link_headings(article)
                elif isinstance(article.html, dict):
                    article.html = {
                        slug: link_headings(type("Post", (), {"html": html}))
                        for slug, html in article.html.items()
                    }

                cache.set(key, article.html, expire=markata.config.default_cache_expire)
    ```
!!! function
    <h2 id="link_headings" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">link_headings <em class="small">function</em></h2>

    Use BeautifulSoup to find all headings and run link_heading on them.

???+ source "link_headings <em class='small'>source</em>"
    ```python
    def link_headings(article: "Post") -> str:
        """
        Use BeautifulSoup to find all headings and run link_heading on them.
        """
        soup = BeautifulSoup(article.html, "html.parser")
        for heading in soup.find_all(re.compile("^h[1-6]$")):
            if (
                not heading.find("a", {"class": "heading-permalink"})
                and heading.get("id", "") != "title"
            ):
                link_heading(soup, heading)
        return str(soup)
    ```
!!! function
    <h2 id="link_heading" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">link_heading <em class="small">function</em></h2>

    Mutate soup to include an svg link at the heading passed in.

???+ source "link_heading <em class='small'>source</em>"
    ```python
    def link_heading(soup: "bs4.BeautifulSoup", heading: "bs4.element.Tag") -> None:
        """
        Mutate soup to include an svg link at the heading passed in.
        """
        id = heading.get("id")

        link = soup.new_tag(
            "a",
            alt="id",
            title=f"link to #{id}",
            href=f"#{id}",
            **{"class": "heading-permalink"},
        )
        span = soup.new_tag("span", **{"class": "visually-hidden"})
        svg = soup.new_tag(
            "svg",
            fill="currentColor",
            focusable="false",
            width="1em",
            height="1em",
            xmlns="http://www.w3.org/2000/svg",
            viewBox="0 0 24 24",
            **{
                "aria-hidden": "true",
            },
        )

        path = soup.new_tag(
            "path",
            d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z",
        )
        svg.append(path)
        link.append(span)
        link.append(svg)
        heading.append(link)
    ```
    ]]></content>
  </entry>
  <entry>
    <title>config_model.py</title>

    <id>https://markata.dev/markata/plugins/config-model/</id>
    <link href="https://markata.dev/markata/plugins/config-model/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin defines Markata's core configuration model, providing validation and type safety for all configuration options. Installation This plugin is…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.config_model` plugin defines Markata's core configuration model,
providing validation and type safety for all configuration options.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.config_model",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.config_model",
]
```

Note: Disabling this plugin will break most of Markata's functionality as the Config
model is fundamental to the system.

## Configuration

Configure Markata in `markata.toml`:

```toml
[markata]
# Core settings
output_dir = "markout"
assets_dir = "static"

# Plugin management
hooks = ["default"]
disabled_hooks = []

# Cache settings
default_cache_expire = 3600
template_cache_expire = 86400  # 24 hours
markdown_cache_expire = 21600  # 6 hours
dynamic_cache_expire = 3600   # 1 hour

# Markdown settings
markdown_extensions = []

# Development settings
dev_server_port = 8000
dev_server_host = "localhost"
```

## Functionality

### Configuration Model

Core settings:
- `output_dir`: Build output location
- `assets_dir`: Static assets location
- `hooks`: Active plugins
- `disabled_hooks`: Disabled plugins
- `markdown_extensions`: Markdown processors
- Cache expiration times
- Development server settings

## Validation

The model provides:
- Type checking and coercion
- Path validation
- URL validation
- Color validation
- Integer constraints
- Default values

## Settings Management

Features:
- Environment variable support
- TOML file loading
- Settings inheritance
- Dynamic updates
- Validation on change

## Performance

Uses optimized Pydantic config:
- Assignment validation
- Arbitrary types
- Extra fields
- String stripping
- Default validation
- Number coercion
- Name population

## Dependencies

This plugin depends on:
- pydantic for model definition
- pydantic-settings for settings management
- pydantic-extra-types for color support
- rich for console output

---

!!! method
    <h2 id="__getitem__" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">__getitem__ <em class="small">method</em></h2>

    for backwards compatability

???+ source "__getitem__ <em class='small'>source</em>"
    ```python
    def __getitem__(self, item):
            "for backwards compatability"
            return getattr(self, item)
    ```
!!! method
    <h2 id="__setitem__" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">__setitem__ <em class="small">method</em></h2>

    for backwards compatability

???+ source "__setitem__ <em class='small'>source</em>"
    ```python
    def __setitem__(self, key, item):
            "for backwards compatability"
            return setattr(self, key, item)
    ```
!!! method
    <h2 id="get" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">get <em class="small">method</em></h2>

    for backwards compatability

???+ source "get <em class='small'>source</em>"
    ```python
    def get(self, item, default):
            "for backwards compatability"
            return getattr(self, item, default)
    ```
!!! method
    <h2 id="keys" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">keys <em class="small">method</em></h2>

    for backwards compatability

???+ source "keys <em class='small'>source</em>"
    ```python
    def keys(self):
            "for backwards compatability"
            return self.__dict__.keys()
    ```
    ]]></content>
  </entry>
  <entry>
    <title>mdit_details.py</title>

    <id>https://markata.dev/markata/plugins/mdit-details/</id>
    <link href="https://markata.dev/markata/plugins/mdit-details/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin adds support for collapsible details/summary sections in markdown using the syntax. This is similar to HTML's element but with a more…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.mdit_details` plugin adds support for collapsible details/summary
sections in markdown using the `???` syntax. This is similar to HTML's `<details>` element
but with a more markdown-friendly syntax.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.mdit_details",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.mdit_details",
]
```

## Configuration

This plugin requires no explicit configuration. It automatically processes details
blocks in your markdown content.

## Functionality

## Basic Usage

Create collapsible sections:
```markdown
??? note "Optional Title"
    This content will be collapsible.
    It can contain *any* markdown.

???+ note "Open by Default"
    The + symbol makes this section expanded by default.
```

## Supported Styles

Default styles include:
- note
- info
- warning
- danger
- success
- question
- abstract
- example

## Syntax Options

The plugin supports:
- Basic: `??? type`
- With title: `??? type "Custom Title"`
- Open by default: `???+ type`
- No title: Title defaults to capitalized type

## HTML Output

Generated HTML structure:
```html
<details class="details type">
  <summary>Title Text</summary>
  <div class="details-content">
    <!-- Markdown content -->
  </div>
</details>
```

## Nesting Support

Details blocks can be nested:
```markdown
??? outer "Outer Section"
    Some content

    ??? inner "Inner Section"
        Nested content
```

## Dependencies

This plugin depends on:
- markdown-it-py for markdown parsing
- The `render_markdown` plugin for final HTML output

---

!!! function
    <h2 id="details_plugin" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">details_plugin <em class="small">function</em></h2>

    Plugin to use
    `python-markdown style detailss
    <https://python-markdown.github.io/extensions/details>`_.

    .. code-block:: md

        ??? note
            *content*

    Note, this is ported from
    `markdown-it-admon
    <https://github.com/commenthol/markdown-it-admon>`_.

???+ source "details_plugin <em class='small'>source</em>"
    ```python
    def details_plugin(md: MarkdownIt, render: Optional[Callable] = None) -> None:
        """Plugin to use
        `python-markdown style detailss
        <https://python-markdown.github.io/extensions/details>`_.

        .. code-block:: md

            ??? note
                *content*

        Note, this is ported from
        `markdown-it-admon
        <https://github.com/commenthol/markdown-it-admon>`_.
        """

        def renderDefault(self, tokens, idx, _options, env):
            return self.renderToken(tokens, idx, _options, env)

        render = render or renderDefault

        md.add_render_rule("details_open", render)
        md.add_render_rule("details_close", render)
        md.add_render_rule("details_title_open", render)
        md.add_render_rule("details_title_close", render)

        md.block.ruler.before(
            "fence",
            "details",
            details,
            {"alt": ["paragraph", "reference", "blockquote", "list"]},
        )
    ```
    ]]></content>
  </entry>
  <entry>
    <title>publish_html.py</title>

    <id>https://markata.dev/markata/plugins/publish-html/</id>
    <link href="https://markata.dev/markata/plugins/publish-html/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin handles saving rendered HTML content to files. It determines the output path for each article and ensures files are saved in the correct location…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.publish_html` plugin handles saving rendered HTML content to files.
It determines the output path for each article and ensures files are saved in the correct
location within the output directory.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.publish_html",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.publish_html",
]
```

Note: Disabling this plugin will prevent HTML files from being written to disk.

## Configuration

Configure HTML output in `markata.toml`:

```toml
[markata]
# Base output directory
output_dir = "dist"

# Custom output paths
[[markata.output_paths]]
pattern = "blog/*"
output = "posts/{stem}.html"

[[markata.output_paths]]
pattern = "docs/*"
output = "documentation/{stem}/index.html"
```

## Functionality

## Path Resolution

The plugin:
1. Determines output path for each post
2. Creates necessary directories
3. Validates paths are within output_dir
4. Handles custom path mappings

## Output Model

Extends the base Post model with:
- output_html path
- Path validation
- Slug resolution
- Directory creation

## File Operations

Handles:
- Directory creation
- File writing
- Path validation
- Error logging

## Path Customization

Supports:
- Custom output paths
- Path patterns
- Directory structures
- Index files

## Safety Features

Includes:
- Path validation
- Directory verification
- Error handling
- Logging

## Dependencies

This plugin depends on:
- pathlib for path operations
- pydantic for model validation

---

!!! function
    <h2 id="save" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">save <em class="small">function</em></h2>

    Saves all the articles to their set `output_html` location if that location
    is relative to the specified `output_dir`.  If its not relative to the
    `output_dir` it will log an error and move on.

???+ source "save <em class='small'>source</em>"
    ```python
    def save(markata: "Markata") -> None:
        """
        Saves all the articles to their set `output_html` location if that location
        is relative to the specified `output_dir`.  If its not relative to the
        `output_dir` it will log an error and move on.
        """
        from slugify import slugify

        for article in markata.filter("not skip"):
            if article.html is None:
                continue

            if isinstance(article.html, str):
                # Create parent directories before writing
                current_html = (
                    article.output_html.read_text() if article.output_html.exists() else ""
                )
                if current_html != article.html:
                    article.output_html.parent.mkdir(parents=True, exist_ok=True)
                    article.output_html.write_text(article.html)
            elif isinstance(article.html, dict):
                for slug, html in article.html.items():
                    # Handle special case for index
                    if slug == "index":
                        output_path = article.output_html
                    # Handle files with extensions
                    elif "." in slug:
                        output_path = article.output_html.parent / slug
                    # Handle other slugs by creating subdirectories
                    else:
                        slug_path = slugify(slug)
                        output_path = article.output_html.parent / slug_path / "index.html"

                    # Create parent directories and write file
                    output_path.parent.mkdir(parents=True, exist_ok=True)
                    current_html = output_path.read_text() if output_path.exists() else ""
                    if current_html != html:
                        output_path.write_text(html)
    ```
    ]]></content>
  </entry>
  <entry>
    <title>test_redirects.py</title>

    <id>https://markata.dev/tests/plugins/test-redirects/</id>
    <link href="https://markata.dev/tests/plugins/test-redirects/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
Tests the redirects plugin
    ]]></summary>

    <content type="html"><![CDATA[
---

Tests the redirects plugin

---

!!! function
    <h2 id="set_directory" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">set_directory <em class="small">function</em></h2>

    context manager to set the directory

???+ source "set_directory <em class='small'>source</em>"
    ```python
    def set_directory(path):
        """
        context manager to set the directory
        """
        cwd = Path.cwd()
        try:
            os.chdir(path)
            yield
        finally:
            os.chdir(cwd)
    ```
!!! function
    <h2 id="test_redirect_exists" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">test_redirect_exists <em class="small">function</em></h2>

    ensure that the default workflow works

???+ source "test_redirect_exists <em class='small'>source</em>"
    ```python
    def test_redirect_exists(tmp_files: Path, old: str, new: str) -> None:
        "ensure that the default workflow works"
        with set_directory(tmp_files):
            m = Markata()
            redirects.save(m)
            redirect_file = Path("markout") / old / "index.html"
            assert redirect_file.exists()
            assert (
                f'<meta http-equiv="Refresh" content="0; url=\'{new}\'" />'
                in redirect_file.read_text()
            )
    ```
!!! function
    <h2 id="test_redirect_ignore_splat" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">test_redirect_ignore_splat <em class="small">function</em></h2>

    splats cannot be supported statically, test that they are ignored

???+ source "test_redirect_ignore_splat <em class='small'>source</em>"
    ```python
    def test_redirect_ignore_splat(tmp_files: Path, old: str) -> None:
        "splats cannot be supported statically, test that they are ignored"
        with set_directory(tmp_files):
            m = Markata()
            redirects.save(m)
            redirect_file = Path("markout") / old / "index.html"
            assert not redirect_file.exists()
    ```
!!! function
    <h2 id="test_redirect_ignore_more_params" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">test_redirect_ignore_more_params <em class="small">function</em></h2>

    status codes cannot be supported statically as they are issued by the server

???+ source "test_redirect_ignore_more_params <em class='small'>source</em>"
    ```python
    def test_redirect_ignore_more_params(tmp_files: Path, old: str) -> None:
        "status codes cannot be supported statically as they are issued by the server"
        with set_directory(tmp_files):
            m = Markata()
            redirects.save(m)
            redirect_file = Path("markout") / old / "index.html"
            assert not redirect_file.exists()
    ```
!!! function
    <h2 id="test_redirect_configure_redirect_file" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">test_redirect_configure_redirect_file <em class="small">function</em></h2>

    ensure that the redirects file can be configured

???+ source "test_redirect_configure_redirect_file <em class='small'>source</em>"
    ```python
    def test_redirect_configure_redirect_file(
        tmp_files: Path, redirect_file: str, old: str, new: str
    ) -> None:
        "ensure that the redirects file can be configured"
        with set_directory(tmp_files):
            m = Markata()
            m.config["redirects"] = redirect_file
            redirects.save(m)
            redirect_html = Path("markout") / old / "index.html"
            assert redirect_html.exists()
            assert (
                f'<meta http-equiv="Refresh" content="0; url=\'{new}\'" />'
                in redirect_html.read_text()
            )
    ```
!!! function
    <h2 id="test_redirect_custom_template" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">test_redirect_custom_template <em class="small">function</em></h2>

    ensure the template can be configured

???+ source "test_redirect_custom_template <em class='small'>source</em>"
    ```python
    def test_redirect_custom_template(
        tmp_files: Path, redirect_template: str, old: str, new: str
    ) -> None:
        "ensure the template can be configured"
        with set_directory(tmp_files):
            m = Markata()
            m.config["redirect_template"] = redirect_template
            redirects.save(m)
            redirect_file = Path("markout") / old / "index.html"
            assert redirect_file.exists()
            assert f"{old} is now {new}" in redirect_file.read_text()
    ```
!!! function
    <h2 id="test_redirect_empty" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">test_redirect_empty <em class="small">function</em></h2>

    ensure empty redirects files work

???+ source "test_redirect_empty <em class='small'>source</em>"
    ```python
    def test_redirect_empty(tmp_files: Path, old: str, new: str) -> None:
        "ensure empty redirects files work"
        with set_directory(tmp_files):
            m = Markata()
            redirects.save(m)
    ```
!!! function
    <h2 id="test_redirect_file_missing" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">test_redirect_file_missing <em class="small">function</em></h2>

    ensure missing redirects file works

???+ source "test_redirect_file_missing <em class='small'>source</em>"
    ```python
    def test_redirect_file_missing(tmpdir: Path) -> None:
        "ensure missing redirects file works"
        with set_directory(tmpdir):
            m = Markata()
            redirects.save(m)
    ```
    ]]></content>
  </entry>
  <entry>
    <title>create_models.py</title>

    <id>https://markata.dev/markata/plugins/create-models/</id>
    <link href="https://markata.dev/markata/plugins/create-models/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin dynamically creates Markata's core Pydantic models by combining model fragments from various plugins. This enables extensible and type-safe data…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.create_models` plugin dynamically creates Markata's core Pydantic
models by combining model fragments from various plugins. This enables extensible and
type-safe data models.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.create_models",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.create_models",
]
```

Note: Disabling this plugin will break most of Markata's functionality as it's
responsible for creating core models.

## Configuration

No explicit configuration is required. The plugin automatically creates models from
registered model fragments.

## Functionality

## Model Creation

The plugin:
1. Collects model fragments from plugins
2. Deduplicates model definitions
3. Creates composite models
4. Registers models with Markata

## Core Models

Creates these models:
- `Post`: Individual post data
- `Posts`: Collection of posts
- `Config`: Global configuration

## Model Configuration

Applies settings:
- Environment variable prefix
- Extra field handling
- Type validation
- Copy behavior
- Base classes

## Performance

Optimizations:
- Unique model deduplication
- Lazy model creation
- Minimal validation
- Efficient inheritance

## Dependencies

This plugin depends on:
- pydantic for model creation
- more-itertools for deduplication

---
    ]]></content>
  </entry>
  <entry>
    <title>create_covers.py</title>

    <id>https://markata.dev/markata/plugins/create-covers/</id>
    <link href="https://markata.dev/markata/plugins/create-covers/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin is a simplified version of the covers plugin. It generates basic cover images with titles using a single template and font configuration.…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.create_covers` plugin is a simplified version of the covers plugin.
It generates basic cover images with titles using a single template and font configuration.

## Installation

This plugin is built-in but NOT enabled by default. To use it, add it to your plugins:

```toml
hooks = [
    "markata.plugins.create_covers",
]
```

## Uninstallation

Since this plugin is not in the default plugin set, simply remove it from your hooks list
to disable it:

```toml
hooks = [
    # Remove or comment out the line below
    # "markata.plugins.create_covers",
]
```

## Configuration

Configure basic cover settings in your `markata.toml`:

```toml
[markata.create_covers]
template = "static/cover-template.png"  # Base template image
font = "./static/OpenSans-Regular.ttf"  # Font file for title
font_color = "rgb(255,255,255)"        # Title color (white)
```

## Functionality

## Cover Generation

The plugin:
1. Loads a single template image
2. Draws the post title using the configured font
3. Automatically sizes text to fit within image bounds
4. Saves the cover as PNG in the output directory

## File Naming

Generated files are named:
- `<slug>.png` in the output directory

## Dependencies

This plugin depends on:
- Pillow (PIL) for image manipulation

Note: For more advanced cover generation with multiple templates and text positioning,
use the `markata.plugins.covers` plugin instead.

---
    ]]></content>
  </entry>
  <entry>
    <title>pyinstrument.py</title>

    <id>https://markata.dev/markata/plugins/pyinstrument/</id>
    <link href="https://markata.dev/markata/plugins/pyinstrument/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin adds performance profiling capabilities using pyinstrument. It generates detailed HTML reports showing where your build spends time. Installation…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.pyinstrument` plugin adds performance profiling capabilities using
pyinstrument. It generates detailed HTML reports showing where your build spends time.

## Installation

This plugin is built-in but not enabled by default. Add it to your plugins list:

```toml
hooks = [
    "markata.plugins.pyinstrument",
]
```

You must also install pyinstrument:
```bash
pip install pyinstrument
```

## Uninstallation

Remove the plugin from your hooks list in `markata.toml`:

```toml
hooks = [
    # Remove or comment out the line below
    # "markata.plugins.pyinstrument",
]
```

## Configuration

Configure profiling in `markata.toml`:

```toml
[markata.profiler]
# Enable/disable profiling
should_profile = true

# Output location (relative to output_dir)
output_file = "_profile/index.html"

# Profile options
interval = 0.001
async_mode = "enabled"
show_all = false
timeline = false
```

## Functionality

## Profiling Features

The plugin:
1. Profiles the entire build process
2. Generates HTML reports
3. Shows time distribution
4. Identifies bottlenecks

## Report Generation

Creates reports with:
- Call tree visualization
- Time percentages
- Function details
- Stack traces

### Configuration Options

Supports:
- Custom output paths
- Sampling intervals
- Async mode settings
- Display options
- Timeline view

## Performance Impact

Note:
- Minimal overhead
- Configurable precision
- Optional async profiling
- Selective profiling

## Dependencies

This plugin depends on:
- pyinstrument for profiling
- pydantic for configuration

---

!!! function
    <h2 id="save" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">save <em class="small">function</em></h2>

    stop the profiler and save as late as possible

???+ source "save <em class='small'>source</em>"
    ```python
    def save(markata: Markata) -> None:
        "stop the profiler and save as late as possible"
        if markata.config.profiler.should_profile:
            if markata.config.profiler.profiler is not None:
                if markata.config.profiler.profiler.is_running:
                    try:
                        markata.config.profiler.profiler.stop()
                        html = markata.config.profiler.profiler.output_html()
                        markata.config.profiler.output_file.write_text(html)
                        markata.console.print(
                            markata.config.profiler.profiler.output_text()
                        )

                    except AttributeError:
                        markata.console.log(
                            "profiler not available, skipping save pyinstrument save",
                        )
                        markata.console.log(
                            r"[red]to enable profiler [wheat1][itallic]pip install 'markata[pyinstrument]'",
                        )
    ```
!!! function
    <h2 id="teardown" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">teardown <em class="small">function</em></h2>

    stop the profiler on exit

???+ source "teardown <em class='small'>source</em>"
    ```python
    def teardown(markata: Markata) -> None:
        "stop the profiler on exit"
        # import logging

        # logger = logging.getLogger()
        # logger.handlers.clear()
        if markata.config.profiler.should_profile:
            if markata.config.profiler.profiler is not None:
                if markata.config.profiler.profiler.is_running:
                    markata.config.profiler.profiler.stop()
    ```
!!! method
    <h2 id="ensure_output_dir_exists" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">ensure_output_dir_exists <em class="small">method</em></h2>

    Ensure output directory exists, creating it if necessary.

???+ source "ensure_output_dir_exists <em class='small'>source</em>"
    ```python
    def ensure_output_dir_exists(cls, v: Union[str, Path]) -> Path:
            """Ensure output directory exists, creating it if necessary."""
            if isinstance(v, str):
                v = Path(v)
            v.mkdir(parents=True, exist_ok=True)
            return v
    ```
    ]]></content>
  </entry>
  <entry>
    <title>test_post_model.py</title>

    <id>https://markata.dev/tests/plugins/test-post-model/</id>
    <link href="https://markata.dev/tests/plugins/test-post-model/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
None
    ]]></summary>

    <content type="html"><![CDATA[
---

None

---
    ]]></content>
  </entry>
  <entry>
    <title>setup_logging.py</title>

    <id>https://markata.dev/markata/plugins/setup-logging/</id>
    <link href="https://markata.dev/markata/plugins/setup-logging/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
Setup Logging hook sets up the RichHandler for pretty console logs, and file logs to the configured markata's configured , or if is not configured. The log…
    ]]></summary>

    <content type="html"><![CDATA[
---

Setup Logging hook sets up the RichHandler for pretty console logs, and file
logs to the configured markata's configured `log_dir`, or `output_dir/_logs` if
`log_dir` is not configured.  The log file will be named after the
`<levelname>.log`

# The log files

There will be 6 log files created based on log level and file type.

```
markout/_logs
├── debug
│   └── index.html
├── debug.log
├── info
│   └── index.html
├── info.log
├── warning
│   └── index.html
└── warning.log
```

## Configuration

Ensure that setup_logging is in your hooks.  You can check if `setup_logging`
is in your hooks by running `markata list --hooks` from your terminal and
checking the output, or creating an instance of `Markata()` and checking the
`Markata().hooks` attribute.  If its missing or you wan to be more explicit,
you can add `setup_logging` to your `markata.toml` `[markata.hooks]`.

``` toml
[markata]

# make sure its in your list of hooks
hooks=[
   "markata.plugins.setup_logging",
   ]
```

# Log Template
``` toml
[markata]

# make sure its in your list of hooks
hooks=[
   "markata.plugins.setup_logging",
   ]

# point log template to the path of your logging template
log_template='templates/log_template.html'
```

You can see the latest default `log_template` on
[GitHub](https://github.com/WaylonWalker/markata/blob/main/markata/plugins/default_log_template.html)

# Disable Logging

If you do not want logging, you can explicityly disable it by adding it to your
`[markata.disabled_hooks]` array in your `[markata.toml]`

``` toml
[markata]

# make sure its in your list of hooks
disabled_hooks=[
   "markata.plugins.setup_logging",
   ]
```

---

!!! function
    <h2 id="has_rich_handler" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">has_rich_handler <em class="small">function</em></h2>

    Returns a boolean whether or not there is a RichHandler attached to the
    root logger.

???+ source "has_rich_handler <em class='small'>source</em>"
    ```python
    def has_rich_handler() -> bool:
        """
        Returns a boolean whether or not there is a RichHandler attached to the
        root logger.
        """

        logger = logging.getLogger()
        return bool([h for h in logger.handlers if isinstance(h, RichHandler)])
    ```
!!! function
    <h2 id="setup_text_log" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">setup_text_log <em class="small">function</em></h2>

    sets up a plain text log in markata's configured `log_dir`, or
    `output_dir/_logs` if `log_dir` is not configured.  The log file will be
    named after the `<levelname>.log`

???+ source "setup_text_log <em class='small'>source</em>"
    ```python
    def setup_text_log(markata: "Markata", level: int = logging.INFO) -> Path:
        """
        sets up a plain text log in markata's configured `log_dir`, or
        `output_dir/_logs` if `log_dir` is not configured.  The log file will be
        named after the `<levelname>.log`
        """
        log_file = markata.config.logging.log_dir / (
            logging.getLevelName(level).lower() + ".log"
        )

        if has_file_handler(log_file):
            return log_file

        if not log_file.parent.exists():
            log_file.parent.mkdir(parents=True)
        fh = logging.FileHandler(log_file)
        fh.setLevel(level)
        fh_formatter = logging.Formatter(
            "%(asctime)s %(name)-12s %(levelname)-8s %(message)s",
        )
        fh.setFormatter(fh_formatter)
        logging.getLogger("").addHandler(fh)

        return log_file
    ```
!!! function
    <h2 id="setup_html_log" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">setup_html_log <em class="small">function</em></h2>

    sets up an html log in markata's configured `log_dir`, or
    `output_dir/_logs` if `log_dir` is not configured.  The log file will be
    named after the `<levelname>/index.html`.  The goal of this is to give

???+ source "setup_html_log <em class='small'>source</em>"
    ```python
    def setup_html_log(markata: "Markata", level: int = logging.INFO) -> Path:
        """
        sets up an html log in markata's configured `log_dir`, or
        `output_dir/_logs` if `log_dir` is not configured.  The log file will be
        named after the `<levelname>/index.html`.  The goal of this is to give
        """

        log_file = (
            markata.config.logging.log_dir
            / logging.getLevelName(level).lower()
            / "index.html"
        )

        if has_file_handler(log_file):
            return log_file

        log_file.parent.mkdir(parents=True, exist_ok=True)

        if not log_file.exists():
            template = Template(
                markata.config.logging.template.read_text(), undefined=SilentUndefined
            )
            log_header = template.render(
                title=markata.config.title + " logs",
                config=markata.config,
            )
            log_file.write_text(log_header)
        with open(log_file, "a") as f:
            command = Path(sys.argv[0]).name + " " + " ".join(sys.argv[1:])
            f.write(
                f"""
                <div style="
                width: 100%;
                height: 20px;
                margin-top: 5rem;
                border-bottom: 1px solid goldenrod;
                text-align: center">
                    <span style="padding: 0 10px;">
                        {datetime.datetime.now()} running "{command}"
                    </span>
                </div>
        """,
            )
        fh = logging.FileHandler(log_file)
        fh.setLevel(level)
        fh_formatter = logging.Formatter(
            """
            <li>
                <p>
                    <span class="time">%(asctime)s</span>
                    <span class="name %(name)s">%(name)-12s</span>
                    <span class="levelname %(levelname)s">%(levelname)-8s</span>
                </p>
                <p class="message">%(message)s</p>
            </li>
            """,
        )
        fh.setFormatter(fh_formatter)
        logging.getLogger("").addHandler(fh)

        return log_file
    ```
    ]]></content>
  </entry>
  <entry>
    <title>post_template.py</title>

    <id>https://markata.dev/markata/plugins/post-template/</id>
    <link href="https://markata.dev/markata/plugins/post-template/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin handles the rendering of posts using Jinja2 templates. It provides extensive configuration options for HTML head elements, styling, and template…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.post_template` plugin handles the rendering of posts using Jinja2
templates. It provides extensive configuration options for HTML head elements, styling,
and template customization.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.post_template",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.post_template",
]
```

## Configuration

## Head Elements

Configure HTML head elements in `markata.toml`:

```toml
# Meta tags
[[markata.head.meta]]
name = "og:type"
content = "article"

[[markata.head.meta]]
name = "og:author"
content = "Your Name"

# Links
[[markata.head.link]]
rel = "canonical"
href = "https://example.com"

# Scripts
[[markata.head.script]]
src = "/assets/main.js"

# Raw HTML
markata.head.text = '''
<style>
  /* Custom CSS */
</style>
'''
```

## Styling

Configure default styles:

```toml
[markata.style]
color_bg = "#1f2022"
color_text = "#eefbfe"
color_link = "#fb30c4"
color_accent = "#e1bd00c9"
body_width = "800px"
```

## Templates

Configure template settings:

```toml
[markata]
# Default template
post_template = "post.html"

# Template directories
templates_dir = "templates"
dynamic_templates_dir = ".markata.cache/templates"
template_cache_dir = ".markata.cache/template_bytecode"

# Jinja environment options
env_options = { trim_blocks = true }
```

## Functionality

## Template Rendering

The plugin:
1. Loads templates from configured directories
2. Compiles and caches templates for performance
3. Renders posts with Jinja2 templating
4. Supports template inheritance and includes
5. Provides template bytecode caching

## Post-Specific Overrides

Each post can override global settings:

```yaml
---
template: custom.html
config_overrides:
  head:
    meta:
      - name: og:type
        content: video
  style:
    color_bg: "#000000"
---
```

## Template Context

Templates have access to:
- Post attributes
- Global configuration
- Custom filters and functions
- Markata instance

## Performance Features

- Template bytecode caching
- Template compilation caching
- Configurable Jinja2 environment
- Efficient head element rendering

## Dependencies

This plugin depends on:
- jinja2 for templating
- pydantic for configuration
- typer for CLI commands

# Add head configuration

This snippet allows users to configure their head in `markata.toml`.

``` html
{{ config.get('head', {}).pop('text') if 'text' in config.get('head',{}).keys() }}
{% for tag, meta in config.get('head', {}).items() %}
    {% for _meta in meta %}
        <{{ tag }}
            {% for attr, value in _meta.items() %}{{ attr }}="{{ value }}"{% endfor %}
        />
    {% endfor %}
{% endfor %}
```

Users can specify any sort of tag in their `markata.toml`

``` toml
[[markata.head.meta]]
name = "og:type"
content = "article"

[[markata.head.meta]]
name = "og:author"
content = "Waylon Walker"
```

The above configuration becomes this once rendered.

``` html
<meta name='og:type' content='article' />
<meta name='og:Author' content='Waylon Walker' />
```

!! Note

    Article variables can be used for dynamic entries like canonical_url
    ``` toml
    [markata]
    url = "markata.dev"

    [[markata.head.meta]]
    href="{{ config.url }}/{{ slug }}/"
    rel="canonical"
    ```

Optionally users can also specify plain text to be appended to the head of
their documents.  This works well for things that involve full blocks.

``` toml
[[markata.head.text]]
value = '''
<script>
    console.log('hello world')
</script>
'''

[[markata.head.text]]
value='''
html  {
    font-family: "Space Mono", monospace;
    background: var(--color-bg);
    color: var(--color-text);
}
'''
```

## Add scripts to head

Markata config also supports adding scripts to the head via configuration.

``` toml
[[ markata.head.script ]]
    src = "https://cdn.tailwindcss.com"

```

---

!!! function
    <h2 id="render_article" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">render_article <em class="small">function</em></h2>

    Render an article using cached templates.

???+ source "render_article <em class='small'>source</em>"
    ```python
    def render_article(markata, cache, article):
        """Render an article using cached templates."""
        templates_mtime = get_templates_mtime(markata.jinja_env)

        key = markata.make_hash(
            "post_template",
            __version__,
            article.key,
            str(templates_mtime),  # Track template file changes
        )
        html = markata.precache.get(key)

        if html is not None:
            return html

        if isinstance(article.template, str):
            template = get_template(markata.jinja_env, article.template)
            html = render_template(markata, article, template)

        if isinstance(article.template, dict):
            html = {
                slug: render_template(markata, article, get_template(markata.jinja_env, template))
                for slug, template in article.template.items()
            }
        cache.set(key, html, expire=markata.config.default_cache_expire)
        return html
    ```
!!! function
    <h2 id="render_template" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">render_template <em class="small">function</em></h2>

    Render a template with article context.

???+ source "render_template <em class='small'>source</em>"
    ```python
    def render_template(markata, article, template):
        """Render a template with article context."""
        merged_config = markata.config

        # Get the body content - prefer article_html, fallback to html
        body = getattr(article, "article_html", None)
        if body is None:
            body = getattr(article, "html", "")

        context = {
            "post": article,
            "markata": markata,
            "config": merged_config,
            "body": body,
        }

        try:
            return template.render(**context)
        except Exception as e:
            markata.console.print(f"[red]Error rendering template for {article.path}[/]")
            markata.console.print(f"[red]{str(e)}[/]")
            raise
    ```
!!! function
    <h2 id="cli" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">cli <em class="small">function</em></h2>

    Markata hook to implement base cli commands.

???+ source "cli <em class='small'>source</em>"
    ```python
    def cli(app: typer.Typer, markata: "Markata") -> None:
        """
        Markata hook to implement base cli commands.
        """

        templates_app = typer.Typer()
        app.add_typer(templates_app, name="templates")

        @templates_app.callback()
        def templates():
            "template management"

        @templates_app.command()
        def show(
            template: str = typer.Argument(None, help="template to show"),
            theme: str = typer.Option(None, help="pygments syntax theme"),
        ) -> None:
            markata.console.quiet = False
            if template is not None:
                # Show specific template
                try:
                    syntax = markata.jinja_env.get_template(template).source
                    markata.console.print(syntax)
                except Exception as e:
                    markata.console.print(
                        f"Error loading template {template}: {str(e)}", style="red"
                    )

                return

            try:
                templates = markata.jinja_env.list_templates()
                markata.console.quiet = False
                markata.console.print("Templates directories:", style="green underline")

                # Show built-in templates directory
                markata_templates = Path(__file__).parents[1] / "templates"
                # markata.console.print(f"  {markata_templates} [grey50](built-in)[/]")

                # Show user template paths
                for path in markata.config.templates_dir:
                    if path == markata_templates:
                        markata.console.print(f"  {path} [grey50](built-in)[/]")
                    elif path == markata.config.dynamic_templates_dir:
                        markata.console.print(f"  {path} [grey50](dynamic)[/]")
                    else:
                        markata.console.print(f"  {path}")

                markata.console.print("\nAvailable templates:", style="green underline")
                for template in sorted(templates):
                    try:
                        source, file, uptodate = markata.jinja_env.loader.get_source(
                            markata.jinja_env, template
                        )
                        if Path(file).is_relative_to(markata.config.dynamic_templates_dir):
                            markata.console.print(
                                f"  {template} -> {file} [grey50](dynamic)[/]"
                            )
                        elif Path(file).is_relative_to(markata_templates):
                            markata.console.print(
                                f"  {template} -> {file} [grey50](built-in)[/]"
                            )
                        else:
                            markata.console.print(f"  {template} -> {file}")
                    except Exception:
                        markata.console.print(f"  {template}")
            except Exception as e:
                markata.console.print(f"Error listing templates: {str(e)}", style="red")
    ```
!!! class
    <h2 id="MarkataTemplateCache" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">MarkataTemplateCache <em class="small">class</em></h2>

    Template bytecode cache for improved performance.

???+ source "MarkataTemplateCache <em class='small'>source</em>"
    ```python
    class MarkataTemplateCache(jinja2.BytecodeCache):
        """Template bytecode cache for improved performance."""

        def __init__(self, directory):
            self.directory = Path(directory)
            self.directory.mkdir(parents=True, exist_ok=True)

        def load_bytecode(self, bucket):
            filename = self.directory / f"{bucket.key}.cache"
            if filename.exists():
                with open(filename, "rb") as f:
                    bucket.bytecode_from_string(f.read())

        def dump_bytecode(self, bucket):
            filename = self.directory / f"{bucket.key}.cache"
            with open(filename, "wb") as f:
                f.write(bucket.bytecode_to_string())
    ```
!!! function
    <h2 id="configure" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">configure <em class="small">function</em></h2>

    Massages the configuration limitations of toml to allow a little bit easier
    experience to the end user making configurations while allowing an simpler
    jinja template.  This enablees the use of the `markata.head.text` list in
    configuration.

???+ source "configure <em class='small'>source</em>"
    ```python
    def configure(markata: "Markata") -> None:
        """
        Massages the configuration limitations of toml to allow a little bit easier
        experience to the end user making configurations while allowing an simpler
        jinja template.  This enablees the use of the `markata.head.text` list in
        configuration.
        """
    ```
!!! function
    <h2 id="pre_render" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">pre_render <em class="small">function</em></h2>

    FOR EACH POST: Massages the configuration limitations of toml/yaml to allow
    a little bit easier experience to the end user making configurations while
    allowing an simpler jinja template.  This enables the use of the
    `markata.head.text` list in configuration.

???+ source "pre_render <em class='small'>source</em>"
    ```python
    def pre_render(markata: "Markata") -> None:
        """
        FOR EACH POST: Massages the configuration limitations of toml/yaml to allow
        a little bit easier experience to the end user making configurations while
        allowing an simpler jinja template.  This enables the use of the
        `markata.head.text` list in configuration.
        """

        # markata.config.dynamic_templates_dir.mkdir(parents=True, exist_ok=True)
        # head_template = markata.config.dynamic_templates_dir / "head.html"
        # head_template.write_text(
        #     markata.jinja_env.get_template("dynamic_head.html").render(
        #         {"markata": markata}
        #     ),
        # )

        for article in [a for a in markata.articles if "config_overrides" in a]:
            raw_text = article.get("config_overrides", {}).get("head", {}).get("text", "")

            if isinstance(raw_text, list):
                article["config_overrides"]["head"]["text"] = "\n".join(
                    flatten([t.values() for t in raw_text]),
                )
    ```
!!! method
    <h2 id="dynamic_templates_in_templates_dir" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">dynamic_templates_in_templates_dir <em class="small">method</em></h2>

    Ensure all required template directories are included in templates_dir.

    Args:
        value: The input templates_dir value, can be Path, str, or List[Path]

    Returns:
        List[Path]: List of template directories including markata templates and dynamic templates

???+ source "dynamic_templates_in_templates_dir <em class='small'>source</em>"
    ```python
    def dynamic_templates_in_templates_dir(cls, value):
            """Ensure all required template directories are included in templates_dir.

            Args:
                value: The input templates_dir value, can be Path, str, or List[Path]

            Returns:
                List[Path]: List of template directories including markata templates and dynamic templates
            """
            markata_templates = Path(__file__).parents[1] / "templates"
            dynamic_templates_dir = Path(".markata.cache/templates")

            # Convert string to Path if needed
            if isinstance(value, str):
                value = Path(value)

            # Convert single Path to list
            if isinstance(value, Path):
                value = [value]

            # Ensure it's a list of Paths
            templates_dir = [Path(p) if isinstance(p, str) else p for p in value]

            # Add required directories if not present
            if markata_templates not in templates_dir:
                templates_dir.append(markata_templates)

            if dynamic_templates_dir not in templates_dir:
                templates_dir.append(dynamic_templates_dir)

            return templates_dir
    ```
!!! function
    <h2 id="templates" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">templates <em class="small">function</em></h2>

    template management

???+ source "templates <em class='small'>source</em>"
    ```python
    def templates():
            "template management"
    ```
    ]]></content>
  </entry>
  <entry>
    <title>publish_source.py</title>

    <id>https://markata.dev/markata/plugins/publish-source/</id>
    <link href="https://markata.dev/markata/plugins/publish-source/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin saves processed markdown files to the output directory, preserving frontmatter and content modifications. This enables source file access alongside…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.publish_source` plugin saves processed markdown files to the output
directory, preserving frontmatter and content modifications. This enables source file
access alongside rendered HTML.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.publish_source",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.publish_source",
]
```

## Configuration

No explicit configuration is required. The plugin automatically saves source files
alongside HTML output.

## Functionality

## File Output

The plugin:
1. Preserves markdown source
2. Maintains frontmatter
3. Creates output directories
4. Uses post slugs for paths

## Path Resolution

Source files are saved:
- At post's slug location
- With .md extension
- In output directory
- Alongside HTML files

## Frontmatter Handling

Handles frontmatter:
- Strips unserializable values
- Preserves YAML compatibility
- Maintains metadata
- Logs stripped fields

## Error Handling

Includes:
- YAML validation
- Path verification
- Directory creation
- Error logging

## Dependencies

This plugin depends on:
- python-frontmatter for YAML handling
- pyyaml for serialization

---

!!! function
    <h2 id="save" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">save <em class="small">function</em></h2>

    Saves the final modified post to the output site as markdown.

    !!! note
        Any keys that are not yaml serializable will be stripped.

???+ source "save <em class='small'>source</em>"
    ```python
    def save(markata: "Markata") -> None:
        """
        Saves the final modified post to the output site as markdown.

        !!! note
            Any keys that are not yaml serializable will be stripped.

        """
        output_dir = Path(str(markata.config["output_dir"]))
        for article in markata.filter(
            "not skip"
        ):  # iter_articles(description="saving source documents"):
            path = Path(
                output_dir / Path(article["slug"]).parent / Path(article["path"]).name,
            )
            current_content = path.read_text() if path.exists() else ""
            if current_content != article.dumps():
                path.parent.mkdir(parents=True, exist_ok=True)
                path.write_text(article.dumps())
    ```
    ]]></content>
  </entry>
  <entry>
    <title>service_worker.py</title>

    <id>https://markata.dev/markata/plugins/service-worker/</id>
    <link href="https://markata.dev/markata/plugins/service-worker/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
Adds a service_worker to your site. This will make it installable on mobile, viewable offline, and potentially more responsive as the user goes between good…
    ]]></summary>

    <content type="html"><![CDATA[
---

Adds a service_worker to your site.  This will make it installable on mobile,
viewable offline, and potentially more responsive as the user goes between good
and bad connections.

## Configuration

Enable this plugin by adding it to your `markata.toml` hooks list.

``` toml
[markata]
hooks=[
  # your hooks
  "markata.plugins.service_worker",
]
```

If you have any content that you want to  precache, add it to the list of
precache.  You can use devtools, change your network to offline, and see what
files send 404's to the console.  These files likely need precache.

``` toml
[markata]
precache_urls = ['archive-styles.css', 'scroll.css', 'manifest.json']
```

# cache busting

Markata uses the checksum.dirhash of your output directory as the cache key.
This is likely to change and bust the cache on every build.

# pre-caching feeds

You can add and entire feed to your precache, this will automatically load
these posts into the cache anytime someone visits your site and their browser
installs the service worker.

Be nice to your users and don't try to install everything possible in their
cache, but maybe a few that they are most likely to click on.

``` toml
[markata.feeds.recent]
filter="date<today and date>today-timedelta(days=30) and published"
sort="slug"
precache=true
```

> note this assumes that the blog implements a published boolean in each posts
frontmatter.

---

!!! function
    <h2 id="render" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">render <em class="small">function</em></h2>

    sets precache_urls in markata.config to be used in
    `markata.plugins.service_worker.save`.

???+ source "render <em class='small'>source</em>"
    ```python
    def render(markata: "Markata") -> None:
        """
        sets precache_urls in markata.config to be used in
        `markata.plugins.service_worker.save`.
        """

        config = markata.config.service_worker

        if config.precache_feeds:
            for feed, config in markata.config.feeds:
                config.precache_urls.append(f"/{feed}/")

        if config.precache_posts:
            with markata.console.status("pre-caching posts...") as status:
                for post in markata.map("post", **config):
                    status.update(f"pre-caching {post.get('slug', '')}...")
                    config.precache_urls.append(f"/{post.get('slug', '')}/")

        config.precache_urls = list(set(config.precache_urls))
    ```
!!! function
    <h2 id="save" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">save <em class="small">function</em></h2>

    Renders the service-worker.js file with your precache urls, and dirhash.

???+ source "save <em class='small'>source</em>"
    ```python
    def save(markata: "Markata") -> None:
        """
        Renders the service-worker.js file with your precache urls, and dirhash.
        """

        template = Template(markata.config.service_worker.template_file.read_text())
        service_worker_js = template.render(
            __version__=__version__,
            config=copy.deepcopy(markata.config),
            output_dirhash=dirhash(markata.config.output_dir),
        )

        output_file = markata.config.output_dir / "service-worker.js"
        current_content = output_file.read_text() if output_file.exists() else ""
        if current_content != service_worker_js:
            output_file.write_text(service_worker_js)
    ```
    ]]></content>
  </entry>
  <entry>
    <title>md_it_wikilinks.py</title>

    <id>https://markata.dev/markata/plugins/md-it-wikilinks/</id>
    <link href="https://markata.dev/markata/plugins/md-it-wikilinks/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin adds support for wiki-style links using double brackets ( ). It automatically resolves links to other posts in your site using file names or slugs.…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.md_it_wikilinks` plugin adds support for wiki-style links using
double brackets (`[[link]]`). It automatically resolves links to other posts in your
site using file names or slugs.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.md_it_wikilinks",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.md_it_wikilinks",
]
```

## Configuration

This plugin requires no explicit configuration. It automatically processes wikilinks
in your markdown content.

## Functionality

## Basic Wikilinks

Simple file-based linking:
```markdown
[[nav]]              -> links to docs/nav.md as /nav
[[blog/post]]        -> links to blog/post.md as /blog/post
[[about|About Me]]   -> links to about.md with "About Me" as text
```

## Smart Slug Resolution

The plugin:
1. Looks up the target file in your content
2. Finds its generated slug
3. Creates a link to the final URL

Example:
```markdown
# File: posts/2024-01-my-post.md
slug: /blog/my-post

# In another file:
[[2024-01-my-post]]  -> links to /blog/my-post
```

## Link Formats

Supports multiple link styles:
- Basic: `[[filename]]`
- With text: `[[filename|Link Text]]`
- With path: `[[folder/file]]`
- With extension: `[[file.md]]` (extension stripped in output)

## HTML Output

Generated HTML structure:
```html
<a class="wikilink" href="/target-slug">Link Text</a>
```

## Error Handling

For broken links:
- Maintains the wikilink syntax
- Adds a 'broken-link' class
- Optionally logs warnings

## Dependencies

This plugin depends on:
- markdown-it-py for markdown parsing
- The `render_markdown` plugin for final HTML output

---

!!! function
    <h2 id="wikilinks_plugin" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">wikilinks_plugin <em class="small">function</em></h2>

    A plugin to create wikilinks tokens.
    These, token should be handled by the renderer.

    ???+ example

        ```md title=markdown
        [[nav]]
        ```

        ```html title=html
        <a class="wikilink" href="/nav">load</a>
        ```

???+ source "wikilinks_plugin <em class='small'>source</em>"
    ```python
    def wikilinks_plugin(
        md: MarkdownIt,
        start_delimiter: str = "[",
        end_delimiter: str = "]",
        markata=None,
    ):
        """A plugin to create wikilinks tokens.
        These, token should be handled by the renderer.

        ???+ example

            ```md title=markdown
            [[nav]]
            ```

            ```html title=html
            <a class="wikilink" href="/nav">load</a>
            ```
        """

        start_char = ord(start_delimiter)
        end_char = ord(end_delimiter)

        def _wikilinks_inline(state: StateInline, silent: bool):
            try:
                if (
                    state.srcCharCode[state.pos] != start_char
                    or state.srcCharCode[state.pos + 1] != start_char
                ):
                    return False
            except IndexError:
                return False

            pos = state.pos + 2
            found_closing = False
            while True:
                try:
                    end = state.srcCharCode.index(end_char, pos)
                except ValueError:
                    return False
                try:
                    if state.srcCharCode[end + 1] == end_char:
                        found_closing = True
                        break
                except IndexError:
                    return False
                pos = end + 2

            if not found_closing:
                return False

            text = state.src[state.pos + 2 : end].strip()
            state.pos = end + 2

            if silent:
                return True

            token = state.push("link_open", "a", 1)
            token.block = False
            token.attrSet("class", "wikilink")
            if "#" in text:
                link, id = text.split("#")
                link = link.strip("/")
            else:
                link, id = text, None

            # possible_pages = markata.filter(
            #     f'str(path).split("/")[-1].split(".")[0].replace("_", "-") == "{link.replace("_", "-")}"',
            # )
            possible_pages = markata.possible_wikilink.get(link, [])
            if len(possible_pages) == 1:
                link = possible_pages[0]
            elif len(possible_pages) > 1:
                if md.options["article"] is None:
                    debug_value = "UNKNOWN"
                else:
                    debug_value = md.options["article"].get(
                        "path",
                        md.options["article"].get(
                            "title", md.options["article"].get("slug", "")
                        ),
                    )
                logger.warning(
                    f"wikilink [[{text}]] has duplicate matches ({possible_pages}) in file '{debug_value}', defaulting to the first match ({possible_pages[0]})",
                )
                link = possible_pages[0]
            else:
                if md.options["article"] is None:
                    debug_value = "UNKNOWN"
                else:
                    debug_value = md.options["article"].get(
                        "path",
                        md.options["article"].get(
                            "title", md.options["article"].get("slug", "")
                        ),
                    )
                logger.warning(
                    f"wikilink [[{text}]] no matches in file '{debug_value}', defaulting to '/{text}'",
                )
                link = text

            if id and not link.endswith(f"#{id}"):
                link = f"{link}#{id}"

            token.attrSet("href", f"/{link}")
            content_token = state.push("text", "", 0)
            content_token.content = text

            token = state.push("link_close", "a", -1)
            token.content = text

            return True

        md.inline.ruler.before("escape", "wikilinks_inline", _wikilinks_inline)
    ```
    ]]></content>
  </entry>
  <entry>
    <title>render_markdown.py</title>

    <id>https://markata.dev/markata/plugins/render-markdown/</id>
    <link href="https://markata.dev/markata/plugins/render-markdown/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin converts markdown content to HTML. This plugin is essential for rendering markdown files loaded by the plugin. Installation This plugin is built-in…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.render_markdown` plugin converts markdown content to HTML.
This plugin is essential for rendering markdown files loaded by the `load` plugin.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.render_markdown",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.render_markdown",
]
```

Note: Disabling this plugin will prevent markdown files from being rendered to HTML.

## Configuration

## Markdown Backend Selection

Choose from 3 supported markdown backends by setting `markdown_backend` in your `markata.toml`:

```toml
## choose your markdown backend
# markdown_backend='markdown'      # Python-Markdown
# markdown_backend='markdown2'     # markdown2
markdown_backend='markdown-it-py'  # markdown-it-py (default)
```

## Backend-Specific Configuration

### markdown-it-py

Configure markdown-it-py behavior in your `markata.toml`:

```toml
[markata.markdown_it_py]
# Set the flavor - options: 'zero', 'commonmark', 'gfm-like'
config = 'gfm-like'

# Enable specific plugins
enable = [
    'table',
    'strikethrough',
    'footnote',
]

# Disable specific plugins
disable = [
    'linkify',
]

# Configure plugins
[markata.markdown_it_py.plugins.footnote]
# Plugin-specific settings here
```

Read more about markdown-it-py settings in their [documentation](https://markdown-it-py.readthedocs.io/en/latest/).

## Cache Configuration

Control markdown rendering cache:

```toml
[markata.render_markdown]
cache_expire = 3600  # Cache expiration in seconds
```

## Functionality

## Registered Attributes

The plugin registers the following attributes on Post objects:
- `html`: The rendered HTML content from the markdown source

## Dependencies

This plugin depends on:
- One of: python-markdown, markdown2, or markdown-it-py (based on configuration)
- The `load` plugin to provide markdown content for rendering

---

!!! function
    <h2 id="configure" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">configure <em class="small">function</em></h2>

    Sets up a markdown instance as md

???+ source "configure <em class='small'>source</em>"
    ```python
    def configure(markata: "Markata") -> None:
        "Sets up a markdown instance as md"
        # if "markdown_extensions" not in markata.config:
        #     markdown_extensions = [""]
        # if isinstance(markata.config["markdown_extensions"], str):
        #     markdown_extensions = [markata.config["markdown_extensions"]]
        # if isinstance(markata.config["markdown_extensions"], list):
        #     markdown_extensions = markata.config["markdown_extensions"]
        # else:
        #     raise TypeError("markdown_extensions should be List[str]")

        # markata.markdown_extensions = [*DEFAULT_MD_EXTENSIONS, *markdown_extensions]

        if (
            markata.config.get("markdown_backend", "")
            .lower()
            .replace(" ", "-")
            .replace("_", "-")
            == "markdown-it-py"
        ):
            from markdown_it import MarkdownIt

            config_update = markata.config.get("markdown_it_py", {}).get(
                "options_update",
                {
                    "linkify": True,
                    "html": True,
                    "typographer": True,
                    "highlight": highlight_code,
                },
            )
            if isinstance(config_update.get("highlight"), str):
                module = config_update["highlight"].split(":")[0]
                func = config_update["highlight"].split(":")[1]
                config_update["highlight"] = getattr(
                    importlib.import_module(module),
                    func,
                )

            markata.md = MarkdownIt(
                markata.config.get("markdown_it_py", {}).get("config", "gfm-like"),
                config_update,
            )
            for plugin in markata.config.get("markdown_it_py", {}).get("enable", []):
                markata.md.enable(plugin)
            for plugin in markata.config.get("markdown_it_py", {}).get("disable", []):
                markata.md.disable(plugin)

            plugins = copy.deepcopy(
                markata.config.get("markdown_it_py", {}).get("plugins", []),
            )
            for plugin in plugins:
                if isinstance(plugin["plugin"], str):
                    plugin["plugin_str"] = plugin["plugin"]
                    plugin_module = plugin["plugin"].split(":")[0]
                    plugin_func = plugin["plugin"].split(":")[1]
                    plugin["plugin"] = getattr(
                        importlib.import_module(plugin_module),
                        plugin_func,
                    )
                plugin["config"] = plugin.get("config", {})
                for k, _v in plugin["config"].items():
                    if k == "markata":
                        plugin["config"][k] = markata

                markata.md = markata.md.use(plugin["plugin"], **plugin["config"])

            markata.md.convert = markata.md.render
            markata.md.toc = ""
        elif (
            markata.config.get("markdown_backend", "")
            .lower()
            .replace(" ", "-")
            .replace("_", "-")
            == "markdown2"
        ):
            import markdown2

            markata.md = markdown2.Markdown(
                extras=markata.config.render_markdown.extensions
            )
            markata.md.toc = ""
        else:
            import markdown

            markata.md = markdown.Markdown(
                extensions=markata.config.render_markdown.extensions
            )
    ```
!!! function
    <h2 id="render" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">render <em class="small">function</em></h2>

    Render markdown content in parallel.

???+ source "render <em class='small'>source</em>"
    ```python
    def render(markata: "Markata") -> None:
        """Render markdown content in parallel."""
        config = markata.config.render_markdown
        articles = list(markata.filter("not skip"))

        with markata.cache as cache:
            with concurrent.futures.ThreadPoolExecutor() as executor:
                render_func = partial(render_article_parallel, markata, config, cache)
                args_list = [(article,) for article in articles]

                for article, html in executor.map(render_func, args_list):
                    article.html = html
                    article.article_html = copy.deepcopy(html)

        markata.rendered_posts = markata.posts
    ```
    ]]></content>
  </entry>
  <entry>
    <title>auto_description.py</title>

    <id>https://markata.dev/markata/plugins/auto-description/</id>
    <link href="https://markata.dev/markata/plugins/auto-description/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin automatically generates descriptions for your posts by extracting text from the first paragraphs of your markdown content. It can create multiple…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.auto_description` plugin automatically generates descriptions for your
posts by extracting text from the first paragraphs of your markdown content. It can create
multiple descriptions of different lengths for different purposes (e.g., SEO, previews).

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.auto_description",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.auto_description",
]
```

## Configuration

Configure multiple description types in your `markata.toml`:

```toml
# Standard description (160 characters)
[markata.auto_description.description]
len = 160

# Longer description (250 characters)
[markata.auto_description.long_description]
len = 250

# Full description (500 characters)
[markata.auto_description.super_description]
len = 500
```

Each description configuration:
- Must be under `markata.auto_description.[name]`
- Requires a `len` parameter specifying maximum character length
- Creates an attribute named after the configuration key

## Frontmatter Override

You can override automatic descriptions by setting them in frontmatter:

```markdown
---
title: My Post
description: My custom description
long_description: A longer custom description
---
```

## Functionality

## Description Generation

The plugin:
1. Converts markdown to plain text
2. Finds the first meaningful paragraphs
3. Truncates to the specified length
4. Ensures clean word breaks
5. Caches results for performance

## Registered Attributes

For each configured description (e.g., `description`, `long_description`), the plugin adds:
- The description attribute with the generated/specified text
- Truncated to the configured length
- Preserving complete words

## Dependencies

This plugin depends on:
- markdown-it-py for markdown parsing

---

!!! function
    <h2 id="get_description" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">get_description <em class="small">function</em></h2>

    Get the full-length description for a single post by converting markdown to plain text.
    Uses markdown-it-py to parse the markdown and extracts text content from all nodes.
    Strips out any HTML tags, returning only plain text. Properly handles markdown links and formatting.

???+ source "get_description <em class='small'>source</em>"
    ```python
    def get_description(article: "Post") -> str:
        """
        Get the full-length description for a single post by converting markdown to plain text.
        Uses markdown-it-py to parse the markdown and extracts text content from all nodes.
        Strips out any HTML tags, returning only plain text. Properly handles markdown links and formatting.
        """
        import re

        from bs4 import BeautifulSoup
        from markdown_it import MarkdownIt

        content = article.content

        # Remove admonitions (e.g., !!!, !!!+, ???, ???+)
        content = re.sub(r'^[!?]{3}\+? .*?$', '', content, flags=re.MULTILINE)

        # Remove CSS class attributes {.class-name}
        content = re.sub(r'\{\.[\w\-]+\}', '', content)

        # Remove Jinja template tags {% %} and {{ }}
        content = re.sub(r'\{%.*?%\}', '', content, flags=re.DOTALL)
        content = re.sub(r'\{\{.*?\}\}', '', content, flags=re.DOTALL)

        # Remove wikilinks [[link]] or [[link|text]]
        content = re.sub(r'\[\[([^\]|]+)(?:\|([^\]]+))?\]\]', lambda m: m.group(2) if m.group(2) else m.group(1), content)

        # Remove HTML comments
        content = re.sub(r'<!--.*?-->', '', content, flags=re.DOTALL)

        # Remove HTML tags before markdown parsing
        soup = BeautifulSoup(content, "html.parser")
        content = soup.get_text(separator=" ")

        def extract_text(tokens):
            text_chunks = []
            for token in tokens:
                # If the token has children, recursively extract from children
                if hasattr(token, "children") and token.children:
                    text_chunks.append(extract_text(token.children))
                elif token.type == "text":
                    text_chunks.append(token.content)
            return " ".join(text_chunks)

        md = MarkdownIt("commonmark")
        tokens = md.parse(content)

        # Recursively extract visible text from all tokens
        description = extract_text(tokens)

        # Clean up excessive whitespace
        description = re.sub(r'\s+', ' ', description).strip()

        return description
    ```
!!! function
    <h2 id="set_description" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">set_description <em class="small">function</em></h2>

    For a given `article`, find the description, put it in the cache, and set
    the configured descriptions for the article.

???+ source "set_description <em class='small'>source</em>"
    ```python
    def set_description(
        markata: "Markata",
        article: "Post",
        cache: "FanoutCache",
        config: Dict,
        max_description: int = 500,
        plugin_text: None = "",
    ) -> None:
        """
        For a given `article`, find the description, put it in the cache, and set
        the configured descriptions for the article.
        """
        key = markata.make_hash(
            "auto_description2",
            article.content,
            plugin_text,
            config,
            __version__,
        )

        description_from_cache = markata.cache.get(key)

        if description_from_cache is None:
            description = get_description(article)[:max_description]
            markata.cache.set(key, description, expire=markata.config.default_cache_expire)
        else:
            description = description_from_cache
        article["description"] = description

        for description_key in config:
            if description_key not in ["cache_expire", "config_key"]:
                desc_len = config[description_key]["len"]

                # Truncate to word boundary and add ellipsis if needed
                def safe_truncate(text, max_len):
                    if len(text) > max_len:
                        truncated = text[:max_len].rstrip()
                        if " " in truncated:
                            truncated = truncated[: truncated.rfind(" ")].rstrip()
                        return truncated + "…"
                    return text

                # overwrites missing (None) and empty ('')
                if not article.metadata.get(description_key):
                    article.metadata[description_key] = safe_truncate(description, desc_len)
                if description_key == "description":
                    article["description"] = safe_truncate(description, desc_len)
    ```
!!! function
    <h2 id="pre_render" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">pre_render <em class="small">function</em></h2>

    The Markata hook that will set descriptions for all posts in the pre-render phase.

???+ source "pre_render <em class='small'>source</em>"
    ```python
    def pre_render(markata: "Markata") -> None:
        """
        The Markata hook that will set descriptions for all posts in the pre-render phase.
        """
        config = markata.get_plugin_config(__file__)

        if "description" not in config.keys():
            config["description"] = {}
            config["description"]["len"] = 160

        if "long_description" not in config.keys():
            config["long_description"] = {}
            config["long_description"]["len"] = 250

        def try_config_get(key: str) -> Any:
            try:
                return config.get(key).get("len") or None
            except AttributeError:
                return None

        max_description = max(
            [
                value
                for description_key in config
                if (value := try_config_get(description_key))
            ],
        )

        with markata.cache as cache:
            # for article in markata.iter_articles("setting auto description"):
            for article in markata.articles:
                set_description(
                    markata=markata,
                    article=article,
                    cache=cache,
                    config=config,
                    max_description=max_description,
                    plugin_text=Path(__file__).read_text(),
                )
    ```
    ]]></content>
  </entry>
  <entry>
    <title>migrate_to_slugify.py</title>

    <id>https://markata.dev/markata/scripts/migrate-to-slugify/</id>
    <link href="https://markata.dev/markata/scripts/migrate-to-slugify/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
Slugify migration for projects moving from markata<0.5.0 into markata>=0.5.0 to run this script install markata>=0.5.0 and run the following. Then make sure…
    ]]></summary>

    <content type="html"><![CDATA[
---

Slugify migration for projects moving from markata<0.5.0 into markata>=0.5.0

to run this script install markata>=0.5.0 and run the following.

``` bash
python -m markata.scripts.migrate_to_slugify
```

Then make sure that you do not explicity turn off slugify and your site is
going to be on to better urls.

``` toml
[markata]
slugify=false
```

---
    ]]></content>
  </entry>
  <entry>
    <title>md_it_highlight_code.py</title>

    <id>https://markata.dev/markata/plugins/md-it-highlight-code/</id>
    <link href="https://markata.dev/markata/plugins/md-it-highlight-code/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin adds syntax highlighting to code blocks in your markdown content. It uses Pygments for highlighting and adds a copy button for easy code sharing.…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.md_it_highlight_code` plugin adds syntax highlighting to code blocks
in your markdown content. It uses Pygments for highlighting and adds a copy button for
easy code sharing.

## Installation

This plugin is built-in and enabled by default through the 'default' plugin.
If you want to be explicit, you can add it to your list of plugins:

```toml
hooks = [
    "markata.plugins.md_it_highlight_code",
]
```

## Uninstallation

Since this plugin is included in the default plugin set, to disable it you must explicitly
add it to the disabled_hooks list if you are using the 'default' plugin:

```toml
disabled_hooks = [
    "markata.plugins.md_it_highlight_code",
]
```

## Configuration

Configure syntax highlighting in your `markata.toml`:

```toml
[markata.highlight_code]
# Optional: Custom CSS class for code blocks
code_class = "highlight"

# Optional: Custom CSS class for copy button
copy_button_class = "copy-button"

# Optional: Custom copy button text
copy_button_text = "Copy"
copy_button_copied_text = "Copied!"
```

## Functionality

## Code Highlighting

The plugin:
1. Detects language from code block info
2. Applies Pygments syntax highlighting
3. Adds line numbers (optional)
4. Wraps code in proper HTML structure
5. Adds a copy-to-clipboard button

## Example Usage

In markdown:
````markdown
```python
def hello_world():
    print("Hello, World!")
```

```javascript
console.log('Hello, World!');
```
````

Generates HTML:
```html
<div class="highlight">
  <button class="copy-button">
    <svg><!-- Copy icon SVG --></svg>
  </button>
  <pre><code class="language-python">
    <span class="def">def</span> <span class="name">hello_world</span>():
        <span class="keyword">print</span>(<span class="string">"Hello, World!"</span>)
  </code></pre>
</div>
```

## Supported Languages

The plugin supports all languages that Pygments recognizes, including:
- Python
- JavaScript
- HTML/CSS
- Bash/Shell
- And many more

## Copy Button

Features:
- Hover-to-show button
- Click-to-copy functionality
- Success feedback
- Accessible keyboard support

## Dependencies

This plugin depends on:
- Pygments for syntax highlighting
- markdown-it-py for markdown parsing

---

!!! function
    <h2 id="highlight_code" class="admonition-title" style="margin: 0; padding: .5rem 1rem;">highlight_code <em class="small">function</em></h2>

    Code highlighter for markdown-it-py.

???+ source "highlight_code <em class='small'>source</em>"
    ```python
    def highlight_code(code, name, attrs, markata=None):
        """Code highlighter for markdown-it-py."""
        # from pygments import highlight
        # from pygments.formatters import HtmlFormatter
        # from pygments.lexers import ClassNotFound, get_lexer_by_name

        try:
            lexer = get_lexer_by_name(name or "text")
        except ClassNotFound:
            lexer = get_lexer_by_name("text")

        import re

        pattern = r'(\w+)\s*=\s*(".*?"|\S+)'
        matches = re.findall(pattern, attrs)
        attrs = dict(matches)

        if attrs.get("hl_lines"):
            formatter = HtmlFormatter(hl_lines=attrs.get("hl_lines"))
        else:
            formatter = HtmlFormatter()

        copy_button = f"""<button class='copy' title='copy code to clipboard' onclick="navigator.clipboard.writeText(this.parentElement.parentElement.querySelector('pre').textContent)">{COPY_ICON}</button>"""

        from markdown_it import MarkdownIt

        md = MarkdownIt(
            "commonmark",
            {
                "html": True,
                "typographer": True,
            },
        )

        if attrs.get("help"):
            help = f"""
            <a href={attrs.get("help").strip("<").strip(">").strip('"').strip("'")} title='help link' class='help'>{HELP_ICON}</a>
            """
        else:
            help = ""
        if attrs.get("title"):
            file = f"""
    <div class='filepath'>
    {md.render(attrs.get("title").strip('"').strip("'"))}
    <div class='right'>
    {help}
    {copy_button}
    </div>
    </div>
    """
        else:
            file = f"""
    <div class='copy-wrapper'>
    {help}
    {copy_button}
    </div>
            """
        return f"""<pre class='wrapper'>
    {file}
    {highlight(code, lexer, formatter)}
    </pre>
    """
    ```
    ]]></content>
  </entry>
  <entry>
    <title>publish_dev_to_source.py</title>

    <id>https://markata.dev/markata/plugins/publish-dev-to-source/</id>
    <link href="https://markata.dev/markata/plugins/publish-dev-to-source/" rel="alternate" />

    <updated>2025-12-09Z</updated>
    <published>2025-12-09Z</published>

    <summary type="html"><![CDATA[
The plugin enables synchronization between your Markata posts and dev.to articles. It handles frontmatter translation and content formatting for dev.to…
    ]]></summary>

    <content type="html"><![CDATA[
---

The `markata.plugins.publish_dev_to_source` plugin enables synchronization between
your Markata posts and dev.to articles. It handles frontmatter translation and content
formatting for dev.to compatibility.

## Installation

This plugin is built-in but not enabled by default. Add it to your plugins list:

```toml
hooks = [
    "markata.plugins.publish_dev_to_source",
]
```

## Uninstallation

Remove the plugin from your hooks list in `markata.toml`:

```toml
hooks = [
    # Remove or comment out the line below
    # "markata.plugins.publish_dev_to_source",
]
```

## Configuration

No explicit configuration is required. The plugin automatically processes posts with
dev.to-specific frontmatter.

## Functionality

## Frontmatter Mapping

Automatically maps these frontmatter fields:
- title
- published
- description
- tags
- canonical_url
- cover_image
- series

## Content Processing

The plugin:
1. Joins consecutive text lines for dev.to formatting
2. Preserves code blocks and lists
3. Maintains markdown compatibility
4. Updates canonical URLs

## Post Model

Extends the base Post model with:
- dev.to-specific fields
- Validation rules
- Performance optimizations

## Publishing Flow

1. Processes posts after rendering
2. Updates frontmatter
3. Formats content
4. Saves changes to source files

## Dependencies

This plugin depends on:
- python-frontmatter for YAML handling
- pydantic for model validation

---
    ]]></content>
  </entry>
</feed>
